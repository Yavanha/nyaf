{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introducing @nyaf # The name @nyaf is an acronym for \"Not Yet Another Framework\". It is, in fact, an entirely new concept of Web development support libraries, a so called \"thin library\". It's simple, has a flat learning curve, doesn't need any special tools. Keep your tool chain, get the power. It can replace all the complex stuff such as React or Angular entirely, indeed. No dependencies! No bullshit! Pure HTML 5 DOM API and ES 2015 Code. Super small, super smart, super powerful. Period! Write frontend apps without the hassle of a complex framework, use the full power of HTML 5, keep a component based style. Elevator Pitch # Since the amazing impact of jQuery in 2006 we have seen an uncountable number of JavaScript frameworks. Some good, some nice, a few excellent. Each time has it's leading frameworks and an audience that loves it. This comes from simple properties. It should save time compared with programming on a more basic level. It should give stability and reliability to your apps where things in the browser's internal parts get messy. And it adds another layer of indirection to make things smooth and good looking, nicely maintainable, and well architectured. But over time, frameworks get elder. And they can't change and involve, because they already have a broad audience and hundreds or thousands of projects rely on them. The manufacturer can't break everything to go the next step. The programmers get stuck. And the world of browser programming has evolved dramatically. Meanwhile, we have an amazingly powerful native API in HTML 5. One of the most important innovations in browser development where Web Components. The API is easy to learn, the support is complete for all modern browsers, and the implementation is stable. At the same time the programming language TypeScript came to us along with a powerful toolset. It's time for the next step. Take the leading tools and create an easy to use library, that covers the hard stuff and be invisible where the native API is almost the best. That's the core idea behind @nyaf . Parts # The library comes in three parts: A core library that handles Web Components the easy way, provide a router for Single Page Apps, and adds a nice template language. A forms library that handles data binding and decorator based validation. A store library that gives your app a state engine using the common flux architecture style. Everything else is simple HTML 5 API, without any restrictions. You can add CSS, other libraries, or your own stuff at almost any position. Additionally, there is small CLI for easy setup and component creation.","title":"Home"},{"location":"#introducing-nyaf","text":"The name @nyaf is an acronym for \"Not Yet Another Framework\". It is, in fact, an entirely new concept of Web development support libraries, a so called \"thin library\". It's simple, has a flat learning curve, doesn't need any special tools. Keep your tool chain, get the power. It can replace all the complex stuff such as React or Angular entirely, indeed. No dependencies! No bullshit! Pure HTML 5 DOM API and ES 2015 Code. Super small, super smart, super powerful. Period! Write frontend apps without the hassle of a complex framework, use the full power of HTML 5, keep a component based style.","title":"Introducing @nyaf"},{"location":"#elevator-pitch","text":"Since the amazing impact of jQuery in 2006 we have seen an uncountable number of JavaScript frameworks. Some good, some nice, a few excellent. Each time has it's leading frameworks and an audience that loves it. This comes from simple properties. It should save time compared with programming on a more basic level. It should give stability and reliability to your apps where things in the browser's internal parts get messy. And it adds another layer of indirection to make things smooth and good looking, nicely maintainable, and well architectured. But over time, frameworks get elder. And they can't change and involve, because they already have a broad audience and hundreds or thousands of projects rely on them. The manufacturer can't break everything to go the next step. The programmers get stuck. And the world of browser programming has evolved dramatically. Meanwhile, we have an amazingly powerful native API in HTML 5. One of the most important innovations in browser development where Web Components. The API is easy to learn, the support is complete for all modern browsers, and the implementation is stable. At the same time the programming language TypeScript came to us along with a powerful toolset. It's time for the next step. Take the leading tools and create an easy to use library, that covers the hard stuff and be invisible where the native API is almost the best. That's the core idea behind @nyaf .","title":"Elevator Pitch"},{"location":"#parts","text":"The library comes in three parts: A core library that handles Web Components the easy way, provide a router for Single Page Apps, and adds a nice template language. A forms library that handles data binding and decorator based validation. A store library that gives your app a state engine using the common flux architecture style. Everything else is simple HTML 5 API, without any restrictions. You can add CSS, other libraries, or your own stuff at almost any position. Additionally, there is small CLI for easy setup and component creation.","title":"Parts"},{"location":"md/babel/","text":"Project Configuration with Babel # If you don't want to use TypeScript, you can still get the full power of @nyaf . All features that the package requires are provided by ES2017 and above. The recommended tool to setup a package for ES2015 any modern browser supports is Babel . This section describes the setup and usage with pure ECMAScript. Setup the Environment # If you use Visual Studio Code it's recommended to tell the editor the specific features you use, especially decorators. To do so, add a file jsconfig.json in the project root and add this content: { \"compilerOptions\": { \"baseUrl\": \"./src\", \"target\": \"es6\", \"module\": \"commonjs\", \"experimentalDecorators\": true }, \"include\": [\"src/**/*\"] } This assumes your sources are in the folder ./src . Adjust the settings according your needs. Project Dependencies # Next add the following dependencies to your project's package.json . This is the current Babel 7 setup. \"dependencies\": { \"@nyaf/forms\": \"^0.6.8\", \"@nyaf/lib\": \"^0.6.8\", \"@nyaf/store\": \"^0.6.8\", \"babel-loader\": \"^8.1.0\" }, \"devDependencies\": { \"@babel/core\": \"^7.11.6\", \"@babel/plugin-proposal-decorators\": \"^7.10.5\", \"@babel/preset-env\": \"^7.11.5\", \"@babel/preset-react\": \"^7.10.4\", \"html-webpack-plugin\": \"^4.4.1\", \"webpack-cli\": \"^3.3.12\", \"webpack\": \"^4.44.1\", \"webpack-dev-server\": \"^3.11.0\" } This setup allows the compilation and packaging with WebPack, but the transformation invoked from WebPack is based on the Babel plug-ins. Configuring Babel # Next, configure Babel to support the features @nyaf needs. This is primarily the JSX namespaces, that are different from React. It's similar to the procedure described for TypeScript. However, the settings look a bit different. You can use either .babelrc or the settings in package.json . The following example shows the settings in package.json (on root level). \"babel\": { \"presets\": [ \"@babel/preset-env\", [ \"@babel/preset-react\", { \"runtime\": \"classic\", \"pragma\": \"JSX.createElement\", \"pragmaFrag\": \"null\" } ] ], \"plugins\": [ [ \"@babel/plugin-proposal-decorators\", { \"legacy\": true } ] ] } The core settings you'll need are preset-react and plugin-proposal-decorators . The first activates the compilation for the JSX namespace JSX.createElement . This is the exact and complete call to the @nyaf JSX module. The second parameter pragmaFrag is the support for the <></> fragment syntax. In React it's React.fragment . In @nyaf it's just nothing, as the JSX module treats a missing element information as fragment. To enforce this, we provide null . The decorator support is provided by a plugin. Babel takes care to compile this using a polyfill so it runs on the selected ECMAScript version. Packer # You can, of course, use any packer. Most examples use WebPack, but it will work with others, too. The following section covers WebPack and Rollup. Configure WebPack # The Babel transpiler can create a bundle, but putting it all together requires additional steps. The most powerful way (not always the easiest) is WebPack. The following webpack.config.js file is all you need to setup WebPack to create a bundle using Babel: const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { entry: './src/main.js', module: { rules: [ { test: /\\.(jsx?)$/, exclude: /node_modules/, use: ['babel-loader'], }, ], }, resolve: { extensions: ['*', '.js', '.jsx'], }, output: { path: __dirname + '/dist', publicPath: '/', filename: 'bundle.js', }, devServer: { contentBase: './dist', }, plugins: [ new HtmlWebpackPlugin({ inject: true, template: './src/index.html', }), ], }; The entry point is the file main.js . All component files have the extension .jsx , so we need to resolve that extension, too. Apart from this the babel-loader invokes the Babel transpiler and these settings, described above, apply here. The bundle is copied to the distribution folder dist and the bundle is added to the HTML file using the appropriate plug-in. Configure Rollup # The following packagejson file shows a setup with Babel and Rollup. It has several plug-ins to handle the tasks required to make a small bundle. We experienced issues with the typical uglify plug-in and got much better results using Terser . Other compression and mangle tools may work, too. { \"name\": \"nyaf-todo\", \"version\": \"0.1.0\", \"private\": true, \"dependencies\": { \"@nyaf/lib\": \"^0.6.2\" }, \"devDependencies\": { \"@babel/cli\": \"^7.11.6\", \"@babel/core\": \"^7.11.6\", \"@babel/plugin-proposal-class-properties\": \"^7.10.4\", \"@babel/plugin-proposal-decorators\": \"^7.10.5\", \"@babel/preset-env\": \"^7.11.5\", \"@babel/preset-react\": \"^7.10.4\", \"@rollup/plugin-babel\": \"^5.2.1\", \"@rollup/plugin-commonjs\": \"^15.1.0\", \"@rollup/plugin-image\": \"^2.0.5\", \"@rollup/plugin-node-resolve\": \"^9.0.0\", \"babel-plugin-external-helpers\": \"^6.22.0\", \"http-server\": \"^0.12.3\", \"rollup\": \"^2.28.1\", \"rollup-plugin-postcss\": \"^3.1.8\", \"terser\": \"^5.3.2\" }, \"scripts\": { \"start\": \"http-server ./dist -p 8080 -o\", \"build\": \"rollup -c && npx terser --compress --mangle -- dist/index.js > dist/index.min.js\", \"test\": \"echo \\\"No tests\\\"\" }, \"browserslist\": { \"production\": [ \">0.2%\", \"not dead\", \"not op_mini all\" ], \"development\": [ \"last 1 chrome version\", \"last 1 firefox version\", \"last 1 safari version\" ] }, \"babel\": { \"presets\": [ [ \"@babel/preset-env\", { \"targets\": { \"esmodules\": true } } ], [ \"@babel/preset-react\", { \"runtime\": \"classic\", \"pragma\": \"JSX.createElement\", \"pragmaFrag\": \"null\" } ] ], \"plugins\": [ [ \"@babel/plugin-proposal-decorators\", { \"legacy\": true } ], \"@babel/plugin-proposal-class-properties\" ] } } The whole build procedure uses this command (here on command line for manual execution): $ npx rollup -c $ npx terser --compress --mangle -- dist/index.js > dist/index.min.js Rollup itself comes with its own configuration. It's JavaScript and consists mainly of some plug-ins. import babel from '@rollup/plugin-babel'; import resolve from '@rollup/plugin-node-resolve'; import commonjs from '@rollup/plugin-commonjs'; import image from '@rollup/plugin-image'; import postcss from 'rollup-plugin-postcss'; const extensions = ['.js', '.jsx']; export default { input: 'src/index.js', output: { file: 'dist/index.js', format: 'iife', name: 'bundle', }, plugins: [ postcss({ plugins: [] }), image(), resolve({ extensions }), commonjs({ include: 'node_modules/**' }), babel({ exclude: 'node_modules/**', }) ], }; This file starts with the processing of inline CSS. In a component you can use something like this: import JSX, { GlobalProvider, BaseComponent, CustomElement } from '@nyaf/lib'; import 'main.css'; @CustomElement('app-main') export class MainComponent extends BaseComponent { // omitted for brevity } Here, the CSS is being importat directly into the code and you can use the class names in JSX elements (the code assumes that main.css has a rule like .ClassName { color: red } ): <div class={ClassName}> A similar behavior happens to image resources with the plug-in @rollup/plugin-image . @rollup/plugin-node-resolve is required to resolve the jsx file extension. It's not really a requiement, the component files could be named .js , but the typical editors and IDEs process the JSX stuff better, then. @rollup/plugin-commonjs is used to handle the umd bundle and import / export syntax. Finally we call Babel to transform the ES2020 JavaScript into something any modern browser can read. Note that in typical Rollup setups the compression is made by rollup-plugin-uglify . This makes trouble processing the umd -files of the @nyaf package. Hence we use Terser to do a final compression for prduction environments. This setup leads to a quite small package. The nyaf-todo app has a final bundle of 26KB zipped, including the @nyaf/lib package, all the CSS, some components, and the loader provided by Rollup. Writing Components # The components look exactly like the ones using TypeScript, apart from missing types and generics. Let's assume you have this index.html : <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> <title>JS Demo</title> </head> <body> <app-main></app-main> </body> </html> This requires to load and upgrade one component. To do this, you need the start procedure in main.js : import JSX, { GlobalProvider } from '@nyaf/lib'; import { MessageComponent } from './components/message.component'; import { MainComponent } from './components/main.component'; GlobalProvider.bootstrap({ components: [MainComponent, MessageComponent], }); The two demo components are shown below. import JSX, { GlobalProvider, BaseComponent, CustomElement } from '@nyaf/lib'; @CustomElement('app-main') export class MainComponent extends BaseComponent { render() { return ( <> <h1>Hello NYAF</h1> <app-message></app-message> </> ); } } import JSX, { GlobalProvider, BaseComponent, CustomElement } from '@nyaf/lib'; @CustomElement('app-message') export class MessageComponent extends BaseComponent { render() { return <div>Hallo @nyaf</div>; } } As you can see you use JSX and decorators along with ES2018 import/export instructions. Improvements # Imagine a main file like this: import JSX, { GlobalProvider } from '@nyaf/lib'; import * as cmp from '@components'; GlobalProvider.bootstrap({ components: [ cmp.MainComponent, cmp.MessageComponent ] }); The import from @components makes it so much more convenient. To setup this local path resolution you need to create an index file ( index.js ) for your components in the root folder of the components: export * from './main.component'; export * from './message.component'; Then, set an alias in webpack.config.js to resolve this file: resolve: { extensions: [\"*\", \".js\", \".jsx\"], alias: { \"@components\": path.join(__dirname, \"src/components\"), }, } To let Visual Studio Code accept this, too, add this jsconfig.json (look for the key paths ): { \"compilerOptions\": { \"baseUrl\": \"./src\", \"target\": \"es6\", \"module\": \"commonjs\", \"experimentalDecorators\": true, \"paths\": { \"@components/*\": [\"./src/components/*\"] } }, \"include\": [\"src/**/*\"] } Both, the alias' for WebPack as well as the paths key can handle multiple entries for more complex setups. Handle the JSX Import # Each component needs to import the JSX namespace in classic mode. This can be simplified by adding the import globally. The following snippet is usually provided in the main.js or index.js file used to configure the app and before calling GlobalProvider.bootstrap . import JSX from \"@nyaf/lib\"; window.JSX = JSX; From now on you can avoid any of the JSX imports in all the component files. Please note, that the new import of JSX that was introduced in React 17 and is supported in Babel 7.9 and newer will be available in @nyaf beginning with version 0.7.0. Bundle Size # For the demo files shown in the code above the whole bundle is 43.7 KB (11.6 KB zipped). The HTML remains with 230 Bytes (squeezed). With all the loader and polyfill stuff this is an extremely small footprint for a client app. Forms and Flux Store would add another 10 KBytes roughly. The @nyaf CLI # The @nyaf CLI currently creates TypeScript projects only. To use Babel and pure JS refer to the documentation in this section.","title":"Project Configuration (JS)"},{"location":"md/babel/#project-configuration-with-babel","text":"If you don't want to use TypeScript, you can still get the full power of @nyaf . All features that the package requires are provided by ES2017 and above. The recommended tool to setup a package for ES2015 any modern browser supports is Babel . This section describes the setup and usage with pure ECMAScript.","title":"Project Configuration with Babel"},{"location":"md/babel/#setup-the-environment","text":"If you use Visual Studio Code it's recommended to tell the editor the specific features you use, especially decorators. To do so, add a file jsconfig.json in the project root and add this content: { \"compilerOptions\": { \"baseUrl\": \"./src\", \"target\": \"es6\", \"module\": \"commonjs\", \"experimentalDecorators\": true }, \"include\": [\"src/**/*\"] } This assumes your sources are in the folder ./src . Adjust the settings according your needs.","title":"Setup the Environment"},{"location":"md/babel/#project-dependencies","text":"Next add the following dependencies to your project's package.json . This is the current Babel 7 setup. \"dependencies\": { \"@nyaf/forms\": \"^0.6.8\", \"@nyaf/lib\": \"^0.6.8\", \"@nyaf/store\": \"^0.6.8\", \"babel-loader\": \"^8.1.0\" }, \"devDependencies\": { \"@babel/core\": \"^7.11.6\", \"@babel/plugin-proposal-decorators\": \"^7.10.5\", \"@babel/preset-env\": \"^7.11.5\", \"@babel/preset-react\": \"^7.10.4\", \"html-webpack-plugin\": \"^4.4.1\", \"webpack-cli\": \"^3.3.12\", \"webpack\": \"^4.44.1\", \"webpack-dev-server\": \"^3.11.0\" } This setup allows the compilation and packaging with WebPack, but the transformation invoked from WebPack is based on the Babel plug-ins.","title":"Project Dependencies"},{"location":"md/babel/#configuring-babel","text":"Next, configure Babel to support the features @nyaf needs. This is primarily the JSX namespaces, that are different from React. It's similar to the procedure described for TypeScript. However, the settings look a bit different. You can use either .babelrc or the settings in package.json . The following example shows the settings in package.json (on root level). \"babel\": { \"presets\": [ \"@babel/preset-env\", [ \"@babel/preset-react\", { \"runtime\": \"classic\", \"pragma\": \"JSX.createElement\", \"pragmaFrag\": \"null\" } ] ], \"plugins\": [ [ \"@babel/plugin-proposal-decorators\", { \"legacy\": true } ] ] } The core settings you'll need are preset-react and plugin-proposal-decorators . The first activates the compilation for the JSX namespace JSX.createElement . This is the exact and complete call to the @nyaf JSX module. The second parameter pragmaFrag is the support for the <></> fragment syntax. In React it's React.fragment . In @nyaf it's just nothing, as the JSX module treats a missing element information as fragment. To enforce this, we provide null . The decorator support is provided by a plugin. Babel takes care to compile this using a polyfill so it runs on the selected ECMAScript version.","title":"Configuring Babel"},{"location":"md/babel/#packer","text":"You can, of course, use any packer. Most examples use WebPack, but it will work with others, too. The following section covers WebPack and Rollup.","title":"Packer"},{"location":"md/babel/#configure-webpack","text":"The Babel transpiler can create a bundle, but putting it all together requires additional steps. The most powerful way (not always the easiest) is WebPack. The following webpack.config.js file is all you need to setup WebPack to create a bundle using Babel: const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { entry: './src/main.js', module: { rules: [ { test: /\\.(jsx?)$/, exclude: /node_modules/, use: ['babel-loader'], }, ], }, resolve: { extensions: ['*', '.js', '.jsx'], }, output: { path: __dirname + '/dist', publicPath: '/', filename: 'bundle.js', }, devServer: { contentBase: './dist', }, plugins: [ new HtmlWebpackPlugin({ inject: true, template: './src/index.html', }), ], }; The entry point is the file main.js . All component files have the extension .jsx , so we need to resolve that extension, too. Apart from this the babel-loader invokes the Babel transpiler and these settings, described above, apply here. The bundle is copied to the distribution folder dist and the bundle is added to the HTML file using the appropriate plug-in.","title":"Configure WebPack"},{"location":"md/babel/#configure-rollup","text":"The following packagejson file shows a setup with Babel and Rollup. It has several plug-ins to handle the tasks required to make a small bundle. We experienced issues with the typical uglify plug-in and got much better results using Terser . Other compression and mangle tools may work, too. { \"name\": \"nyaf-todo\", \"version\": \"0.1.0\", \"private\": true, \"dependencies\": { \"@nyaf/lib\": \"^0.6.2\" }, \"devDependencies\": { \"@babel/cli\": \"^7.11.6\", \"@babel/core\": \"^7.11.6\", \"@babel/plugin-proposal-class-properties\": \"^7.10.4\", \"@babel/plugin-proposal-decorators\": \"^7.10.5\", \"@babel/preset-env\": \"^7.11.5\", \"@babel/preset-react\": \"^7.10.4\", \"@rollup/plugin-babel\": \"^5.2.1\", \"@rollup/plugin-commonjs\": \"^15.1.0\", \"@rollup/plugin-image\": \"^2.0.5\", \"@rollup/plugin-node-resolve\": \"^9.0.0\", \"babel-plugin-external-helpers\": \"^6.22.0\", \"http-server\": \"^0.12.3\", \"rollup\": \"^2.28.1\", \"rollup-plugin-postcss\": \"^3.1.8\", \"terser\": \"^5.3.2\" }, \"scripts\": { \"start\": \"http-server ./dist -p 8080 -o\", \"build\": \"rollup -c && npx terser --compress --mangle -- dist/index.js > dist/index.min.js\", \"test\": \"echo \\\"No tests\\\"\" }, \"browserslist\": { \"production\": [ \">0.2%\", \"not dead\", \"not op_mini all\" ], \"development\": [ \"last 1 chrome version\", \"last 1 firefox version\", \"last 1 safari version\" ] }, \"babel\": { \"presets\": [ [ \"@babel/preset-env\", { \"targets\": { \"esmodules\": true } } ], [ \"@babel/preset-react\", { \"runtime\": \"classic\", \"pragma\": \"JSX.createElement\", \"pragmaFrag\": \"null\" } ] ], \"plugins\": [ [ \"@babel/plugin-proposal-decorators\", { \"legacy\": true } ], \"@babel/plugin-proposal-class-properties\" ] } } The whole build procedure uses this command (here on command line for manual execution): $ npx rollup -c $ npx terser --compress --mangle -- dist/index.js > dist/index.min.js Rollup itself comes with its own configuration. It's JavaScript and consists mainly of some plug-ins. import babel from '@rollup/plugin-babel'; import resolve from '@rollup/plugin-node-resolve'; import commonjs from '@rollup/plugin-commonjs'; import image from '@rollup/plugin-image'; import postcss from 'rollup-plugin-postcss'; const extensions = ['.js', '.jsx']; export default { input: 'src/index.js', output: { file: 'dist/index.js', format: 'iife', name: 'bundle', }, plugins: [ postcss({ plugins: [] }), image(), resolve({ extensions }), commonjs({ include: 'node_modules/**' }), babel({ exclude: 'node_modules/**', }) ], }; This file starts with the processing of inline CSS. In a component you can use something like this: import JSX, { GlobalProvider, BaseComponent, CustomElement } from '@nyaf/lib'; import 'main.css'; @CustomElement('app-main') export class MainComponent extends BaseComponent { // omitted for brevity } Here, the CSS is being importat directly into the code and you can use the class names in JSX elements (the code assumes that main.css has a rule like .ClassName { color: red } ): <div class={ClassName}> A similar behavior happens to image resources with the plug-in @rollup/plugin-image . @rollup/plugin-node-resolve is required to resolve the jsx file extension. It's not really a requiement, the component files could be named .js , but the typical editors and IDEs process the JSX stuff better, then. @rollup/plugin-commonjs is used to handle the umd bundle and import / export syntax. Finally we call Babel to transform the ES2020 JavaScript into something any modern browser can read. Note that in typical Rollup setups the compression is made by rollup-plugin-uglify . This makes trouble processing the umd -files of the @nyaf package. Hence we use Terser to do a final compression for prduction environments. This setup leads to a quite small package. The nyaf-todo app has a final bundle of 26KB zipped, including the @nyaf/lib package, all the CSS, some components, and the loader provided by Rollup.","title":"Configure Rollup"},{"location":"md/babel/#writing-components","text":"The components look exactly like the ones using TypeScript, apart from missing types and generics. Let's assume you have this index.html : <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> <title>JS Demo</title> </head> <body> <app-main></app-main> </body> </html> This requires to load and upgrade one component. To do this, you need the start procedure in main.js : import JSX, { GlobalProvider } from '@nyaf/lib'; import { MessageComponent } from './components/message.component'; import { MainComponent } from './components/main.component'; GlobalProvider.bootstrap({ components: [MainComponent, MessageComponent], }); The two demo components are shown below. import JSX, { GlobalProvider, BaseComponent, CustomElement } from '@nyaf/lib'; @CustomElement('app-main') export class MainComponent extends BaseComponent { render() { return ( <> <h1>Hello NYAF</h1> <app-message></app-message> </> ); } } import JSX, { GlobalProvider, BaseComponent, CustomElement } from '@nyaf/lib'; @CustomElement('app-message') export class MessageComponent extends BaseComponent { render() { return <div>Hallo @nyaf</div>; } } As you can see you use JSX and decorators along with ES2018 import/export instructions.","title":"Writing Components"},{"location":"md/babel/#improvements","text":"Imagine a main file like this: import JSX, { GlobalProvider } from '@nyaf/lib'; import * as cmp from '@components'; GlobalProvider.bootstrap({ components: [ cmp.MainComponent, cmp.MessageComponent ] }); The import from @components makes it so much more convenient. To setup this local path resolution you need to create an index file ( index.js ) for your components in the root folder of the components: export * from './main.component'; export * from './message.component'; Then, set an alias in webpack.config.js to resolve this file: resolve: { extensions: [\"*\", \".js\", \".jsx\"], alias: { \"@components\": path.join(__dirname, \"src/components\"), }, } To let Visual Studio Code accept this, too, add this jsconfig.json (look for the key paths ): { \"compilerOptions\": { \"baseUrl\": \"./src\", \"target\": \"es6\", \"module\": \"commonjs\", \"experimentalDecorators\": true, \"paths\": { \"@components/*\": [\"./src/components/*\"] } }, \"include\": [\"src/**/*\"] } Both, the alias' for WebPack as well as the paths key can handle multiple entries for more complex setups.","title":"Improvements"},{"location":"md/babel/#handle-the-jsx-import","text":"Each component needs to import the JSX namespace in classic mode. This can be simplified by adding the import globally. The following snippet is usually provided in the main.js or index.js file used to configure the app and before calling GlobalProvider.bootstrap . import JSX from \"@nyaf/lib\"; window.JSX = JSX; From now on you can avoid any of the JSX imports in all the component files. Please note, that the new import of JSX that was introduced in React 17 and is supported in Babel 7.9 and newer will be available in @nyaf beginning with version 0.7.0.","title":"Handle the JSX Import"},{"location":"md/babel/#bundle-size","text":"For the demo files shown in the code above the whole bundle is 43.7 KB (11.6 KB zipped). The HTML remains with 230 Bytes (squeezed). With all the loader and polyfill stuff this is an extremely small footprint for a client app. Forms and Flux Store would add another 10 KBytes roughly.","title":"Bundle Size"},{"location":"md/babel/#the-nyaf-cli","text":"The @nyaf CLI currently creates TypeScript projects only. To use Babel and pure JS refer to the documentation in this section.","title":"The @nyaf CLI"},{"location":"md/config/","text":"Configuration Files # Because the preferred installation is based on TypeScript, it's very recommended to use WebPack and TypeScript's configuration file tsconfig.json . Project # The package.json of your project may look like this: { \"name\": \"your-project\", \"version\": \"0.0.0\", \"description\": \"My first @nyaf project\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"no test defined\\\"\", \"start\": \"webpack-dev-server\", \"build\": \"webpack\" }, \"devDependencies\": { \"@types/node\": \"^12.12.26\", \"clean-webpack-plugin\": \"^3.0.0\", \"copy-webpack-plugin\": \"^6.0.2\", \"css-loader\": \"^3.6.0\", \"file-loader\": \"^6.0.0\", \"html-webpack-plugin\": \"^4.3.0\", \"postcss-loader\": \"^3.0.0\", \"style-loader\": \"^1.2.1\", \"ts-loader\": \"^7.0.5\", \"tsconfig-paths-webpack-plugin\": \"^3.2.0\", \"typescript\": \"^3.9.5\", \"webpack\": \"^4.41.5\", \"webpack-cli\": \"^3.3.10\", \"webpack-dev-server\": \"^3.10.1\" }, \"dependencies\": { \"@nyaf/cli\": \"~0.6.8\", \"@nyaf/lib\": \"~0.6.8\" } } Of course, you have to add anything you might need in addition to that, such as CSS frameworks, fonts, or specific libraries. Also it's worth to note that the various WebPack plug-ins are just a recommendation and you can replace the whole packer stuff with whatever you like. The only thing really needed is the package @nyaf/lib . TypeScript # The tsconfig.json looks like this: { \"compilerOptions\": { \"target\": \"es2015\", \"module\": \"commonjs\", \"moduleResolution\": \"node\", \"resolveJsonModule\": true, \"sourceMap\": true, \"lib\": [ \"es2018\", \"es5\", \"dom\" ], \"jsx\": \"react\", \"declaration\": true, \"reactNamespace\": \"JSX\", \"experimentalDecorators\": true, \"noImplicitAny\": false, \"suppressImplicitAnyIndexErrors\": true, \"removeComments\": false, \"outDir\": \"out-tsc\", \"baseUrl\": \"src\", \"typeRoots\": [ \"node_modules/@types\", \"src/types\" ] } } WebPack # The webpack.config.json looks like this (with SCSS support and dev server): const dev = process.env.NODE_ENV === 'dev'; const path = require('path'); const webpack = require('webpack'); const HtmlWebpackPlugin = require('html-webpack-plugin'); // Main entry point const indexConfig = { template: './src/index.html', inject: 'body', baseHref: './' }; const webpackConfig = { mode: 'development', // How source maps are generated : style of source mapping devtool: dev ? 'eval-cheap-module-source-map' : false, // Development server configuration devServer: { historyApiFallback: true, contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000 }, // Where webpack looks to start building the bundle entry: { app: './src/main.ts' // Demo app entry point }, // How the different types of modules within a project will be treated module: { rules: [ { test: /\\.ts|\\.tsx$/, loader: 'ts-loader' }, // All files with a '.scss' extension will be handled by sass-loader { test: /\\.(scss)$/, use: [ 'style-loader', 'css-loader', 'sass-loader' ] // }) }, // CSS loader { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ] }, // Configure how modules are resolved resolve: { extensions: ['.ts', '.tsx', '.js', '.scss'] }, // How and where webpack should output bundles, assets and anything else output: { path: path.resolve('./dist'), filename: '[name].js' }, // What bundle information gets displayed stats: { warnings: false }, // Target a specific environment (cf. doc) target: 'web', // Customize the webpack build process with additionals plugins plugins: [ new HtmlWebpackPlugin(indexConfig) ] }; // Export the config module.exports = webpackConfig; The package.json gets an entry in scripts section: build: \"webpack\", The Build Process # Now, on command line, just type npm run build . To start WebPack's dev server type: npm start An now enjoy writing a component based SPA with only 34 KB of lib code in total.","title":"Configuration Files"},{"location":"md/config/#configuration-files","text":"Because the preferred installation is based on TypeScript, it's very recommended to use WebPack and TypeScript's configuration file tsconfig.json .","title":"Configuration Files"},{"location":"md/config/#project","text":"The package.json of your project may look like this: { \"name\": \"your-project\", \"version\": \"0.0.0\", \"description\": \"My first @nyaf project\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"no test defined\\\"\", \"start\": \"webpack-dev-server\", \"build\": \"webpack\" }, \"devDependencies\": { \"@types/node\": \"^12.12.26\", \"clean-webpack-plugin\": \"^3.0.0\", \"copy-webpack-plugin\": \"^6.0.2\", \"css-loader\": \"^3.6.0\", \"file-loader\": \"^6.0.0\", \"html-webpack-plugin\": \"^4.3.0\", \"postcss-loader\": \"^3.0.0\", \"style-loader\": \"^1.2.1\", \"ts-loader\": \"^7.0.5\", \"tsconfig-paths-webpack-plugin\": \"^3.2.0\", \"typescript\": \"^3.9.5\", \"webpack\": \"^4.41.5\", \"webpack-cli\": \"^3.3.10\", \"webpack-dev-server\": \"^3.10.1\" }, \"dependencies\": { \"@nyaf/cli\": \"~0.6.8\", \"@nyaf/lib\": \"~0.6.8\" } } Of course, you have to add anything you might need in addition to that, such as CSS frameworks, fonts, or specific libraries. Also it's worth to note that the various WebPack plug-ins are just a recommendation and you can replace the whole packer stuff with whatever you like. The only thing really needed is the package @nyaf/lib .","title":"Project"},{"location":"md/config/#typescript","text":"The tsconfig.json looks like this: { \"compilerOptions\": { \"target\": \"es2015\", \"module\": \"commonjs\", \"moduleResolution\": \"node\", \"resolveJsonModule\": true, \"sourceMap\": true, \"lib\": [ \"es2018\", \"es5\", \"dom\" ], \"jsx\": \"react\", \"declaration\": true, \"reactNamespace\": \"JSX\", \"experimentalDecorators\": true, \"noImplicitAny\": false, \"suppressImplicitAnyIndexErrors\": true, \"removeComments\": false, \"outDir\": \"out-tsc\", \"baseUrl\": \"src\", \"typeRoots\": [ \"node_modules/@types\", \"src/types\" ] } }","title":"TypeScript"},{"location":"md/config/#webpack","text":"The webpack.config.json looks like this (with SCSS support and dev server): const dev = process.env.NODE_ENV === 'dev'; const path = require('path'); const webpack = require('webpack'); const HtmlWebpackPlugin = require('html-webpack-plugin'); // Main entry point const indexConfig = { template: './src/index.html', inject: 'body', baseHref: './' }; const webpackConfig = { mode: 'development', // How source maps are generated : style of source mapping devtool: dev ? 'eval-cheap-module-source-map' : false, // Development server configuration devServer: { historyApiFallback: true, contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000 }, // Where webpack looks to start building the bundle entry: { app: './src/main.ts' // Demo app entry point }, // How the different types of modules within a project will be treated module: { rules: [ { test: /\\.ts|\\.tsx$/, loader: 'ts-loader' }, // All files with a '.scss' extension will be handled by sass-loader { test: /\\.(scss)$/, use: [ 'style-loader', 'css-loader', 'sass-loader' ] // }) }, // CSS loader { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ] }, // Configure how modules are resolved resolve: { extensions: ['.ts', '.tsx', '.js', '.scss'] }, // How and where webpack should output bundles, assets and anything else output: { path: path.resolve('./dist'), filename: '[name].js' }, // What bundle information gets displayed stats: { warnings: false }, // Target a specific environment (cf. doc) target: 'web', // Customize the webpack build process with additionals plugins plugins: [ new HtmlWebpackPlugin(indexConfig) ] }; // Export the config module.exports = webpackConfig; The package.json gets an entry in scripts section: build: \"webpack\",","title":"WebPack"},{"location":"md/config/#the-build-process","text":"Now, on command line, just type npm run build . To start WebPack's dev server type: npm start An now enjoy writing a component based SPA with only 34 KB of lib code in total.","title":"The Build Process"},{"location":"md/intro/","text":"Approach # @nyaf uses JSX/TSX syntax for quick component dev. This is default option, you can use other any template system instead. @nyaf supports Single Page App (SPA) directly. @nyaf can use any current HTML 5 API, such as web components, fetch, and all this with ES2015+. @nyaf provides a simple template language, that avoids clunky map, reduce, filter stuff within the HTML. This is a feature of the JSX/TSX provider. @nyaf uses TypeScript from the beginning (and is written in TypeScript). It works with pure ECMAScript, though. @nyaf creates a very small package. @nyaf works well with WebPack and other common tools. @nyaf uses standards, no weird or enforced CLI, no vendor lock in. @nyaf uses smart decorators for controlling stuff, not code within the component, for separation of concerns style. Templates # @nyaf prefers to use TSX for templates. It does not use React, though. In fact, it's just a feature of the TypeScript compiler. See this excerpt from tsconfig.json : \"jsx\": \"react\", \"reactNamespace\": \"JSX\", The class JSX is the core, it handles the element definitions and extract the template extensions. You can use Babel to setup a pure JS environment without any restrictions. TypeScript is not enforced, it's just an option. Also you can use any other method to create the components content, but you will loose the n-xxx template extensions. Size # Is it worth coding with @nyaf and vanilla JS/TS? For smaller projects and for apps that must load quickly, yes. Actual package sizes (0.6.8, published 16th of September 2020): Lib: 31 KB --> 11 KB zipped (always needed) Forms: 27 KB --> 6 KB zipped (Forms binding, validation, decorators) Store: 11 KB --> 3 KB zipped (Flux like store for state management) Total: 69 KB --> 18 KB zipped all files together for your project However, compared with React or Angular it's a lot simpler. Compared to Vue, Svelte or Polymer it's simpler and even smaller, but the delta is not that thrilling. Tool Support # What tool support? It's Web Components - any editor will do. It's JSX/TSX, so any good editor can handle this. And there are TypeScript decorators, even this is well supported. So, you don't need to tweak your editor. It works, no red squiggles, guaranteed. Restrictions # The package runs, if there are no polyfills, only with ES2015. This limits the usage to any modern browser. It's pretty bold in Electron projects. Credits # Inspired by: Angular (thanks for the idea of using decorators) Polymer (especially lit-element, thanks for showing that Web Components are bold) React (thanks for JSX) Vue (thanks for showing short custom attributes) Svelte (thanks for showing short custom attributes) TypeScript (thanks for making JS cool again)","title":"Introduction"},{"location":"md/intro/#approach","text":"@nyaf uses JSX/TSX syntax for quick component dev. This is default option, you can use other any template system instead. @nyaf supports Single Page App (SPA) directly. @nyaf can use any current HTML 5 API, such as web components, fetch, and all this with ES2015+. @nyaf provides a simple template language, that avoids clunky map, reduce, filter stuff within the HTML. This is a feature of the JSX/TSX provider. @nyaf uses TypeScript from the beginning (and is written in TypeScript). It works with pure ECMAScript, though. @nyaf creates a very small package. @nyaf works well with WebPack and other common tools. @nyaf uses standards, no weird or enforced CLI, no vendor lock in. @nyaf uses smart decorators for controlling stuff, not code within the component, for separation of concerns style.","title":"Approach"},{"location":"md/intro/#templates","text":"@nyaf prefers to use TSX for templates. It does not use React, though. In fact, it's just a feature of the TypeScript compiler. See this excerpt from tsconfig.json : \"jsx\": \"react\", \"reactNamespace\": \"JSX\", The class JSX is the core, it handles the element definitions and extract the template extensions. You can use Babel to setup a pure JS environment without any restrictions. TypeScript is not enforced, it's just an option. Also you can use any other method to create the components content, but you will loose the n-xxx template extensions.","title":"Templates"},{"location":"md/intro/#size","text":"Is it worth coding with @nyaf and vanilla JS/TS? For smaller projects and for apps that must load quickly, yes. Actual package sizes (0.6.8, published 16th of September 2020): Lib: 31 KB --> 11 KB zipped (always needed) Forms: 27 KB --> 6 KB zipped (Forms binding, validation, decorators) Store: 11 KB --> 3 KB zipped (Flux like store for state management) Total: 69 KB --> 18 KB zipped all files together for your project However, compared with React or Angular it's a lot simpler. Compared to Vue, Svelte or Polymer it's simpler and even smaller, but the delta is not that thrilling.","title":"Size"},{"location":"md/intro/#tool-support","text":"What tool support? It's Web Components - any editor will do. It's JSX/TSX, so any good editor can handle this. And there are TypeScript decorators, even this is well supported. So, you don't need to tweak your editor. It works, no red squiggles, guaranteed.","title":"Tool Support"},{"location":"md/intro/#restrictions","text":"The package runs, if there are no polyfills, only with ES2015. This limits the usage to any modern browser. It's pretty bold in Electron projects.","title":"Restrictions"},{"location":"md/intro/#credits","text":"Inspired by: Angular (thanks for the idea of using decorators) Polymer (especially lit-element, thanks for showing that Web Components are bold) React (thanks for JSX) Vue (thanks for showing short custom attributes) Svelte (thanks for showing short custom attributes) TypeScript (thanks for making JS cool again)","title":"Credits"},{"location":"md/learn/","text":"Learn @nyaf # @nyaf is a JavaScript library for building user interfaces. Learn what @nyaf is all about on our homepage or in the tutorial. Try @nyaf # @nyaf has been designed from the start for gradual adoption, and you can use as little or as much @nyaf as you need. Whether you want to get a taste of @nyaf , add some interactivity to a simple HTML page, or start a complex @nyaf -powered app, the links in this section will help you get started. Online Playgrounds # If you\u2019re interested in playing around with @nyaf , you can use an online code playground. Try a Hello World template on CodePen, CodeSandbox, Glitch, or Stackblitz. If you prefer to use your own text editor, you can also download this HTML file, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation, so we\u2019d only recommend using this for simple demos. Add @nyaf to a Website # You can add @nyaf to an HTML page in one minute. You can then either gradually expand its presence, or keep it contained to a few dynamic widgets. Create a New @nyaf App # When starting a @nyaf project, a simple HTML page with script tags might still be the best option. It only takes a minute to set up! As your application grows, you might want to consider a more integrated setup. There are several JavaScript tool-chains we recommend for larger applications. Each of them can work with little to no configuration and lets you take full advantage of the rich @nyaf ecosystem. Learn how. Learning Strategies # People come to @nyaf from different backgrounds and with different learning styles. Whether you prefer a more theoretical or a practical approach, we hope you\u2019ll find this section helpful. If you prefer to learn by doing, start with our practical tutorial. If you prefer to learn concepts step by step, start with our guide to main concepts. Like any unfamiliar technology, @nyaf does have a learning curve. With practice and some patience, you will get the hang of it. First Examples # The @nyaf homepage contains a few small @nyaf examples with a live editor. Even if you don\u2019t know anything about @nyaf yet, try changing their code and see how it affects the result. @nyaf for Beginners # If you feel that the @nyaf documentation goes at a faster pace than you\u2019re comfortable with, check out this overview of @nyaf by Tania Rascia. It introduces the most important @nyaf concepts in a detailed, beginner-friendly way. Once you\u2019re done, give the documentation another try! @nyaf for Designers # If you\u2019re coming from a design background, these resources are a great place to get started. JavaScript Resources # The @nyaf documentation assumes some familiarity with programming in the JavaScript language. You don\u2019t have to be an expert, but it\u2019s harder to learn both @nyaf and JavaScript at the same time. We recommend going through this JavaScript overview to check your knowledge level. It will take you between 30 minutes and an hour but you will feel more confident learning @nyaf . Tip: Whenever you get confused by something in JavaScript, MDN and javascript.info are great websites to check. There are also community support forums where you can ask for help. Practical Tutorial # If you prefer to learn by doing, check out our practical tutorial. In this tutorial, we build a tic-tac-toe game in @nyaf . You might be tempted to skip it because you\u2019re not into building games \u2014 but give it a chance. The techniques you\u2019ll learn in the tutorial are fundamental to building any @nyaf apps, and mastering it will give you a much deeper understanding. Step-by-Step Guide # If you prefer to learn concepts step by step, our guide to main concepts is the best place to start. Every next chapter in it builds on the knowledge introduced in the previous chapters so you won\u2019t miss anything as you go along. Thinking in @nyaf # Many @nyaf users credit reading Thinking in @nyaf as the moment @nyaf finally \u201cclicked\u201d for them. It\u2019s probably the oldest @nyaf walk-through but it\u2019s still just as relevant. Recommended Courses # Sometimes people find third-party books and video courses more helpful than the official documentation. We maintain a list of commonly recommended resources, some of which are free. Advanced Concepts # Once you\u2019re comfortable with the main concepts and played with @nyaf a little bit, you might be interested in more advanced topics. This section will introduce you to the powerful, but less commonly used @nyaf features like context and refs. API Reference # This documentation section is useful when you want to learn more details about a particular @nyaf API. For example, @nyaf .Component API reference can provide you with details on how setState() works, and what different lifecycle methods are useful for. Glossary and FAQ # The glossary contains an overview of the most common terms you\u2019ll see in the @nyaf documentation. There is also a FAQ section dedicated to short questions and answers about common topics, including making AJAX requests, component state, and file structure.","title":"Learn"},{"location":"md/learn/#learn-nyaf","text":"@nyaf is a JavaScript library for building user interfaces. Learn what @nyaf is all about on our homepage or in the tutorial.","title":"Learn @nyaf"},{"location":"md/learn/#try-nyaf","text":"@nyaf has been designed from the start for gradual adoption, and you can use as little or as much @nyaf as you need. Whether you want to get a taste of @nyaf , add some interactivity to a simple HTML page, or start a complex @nyaf -powered app, the links in this section will help you get started.","title":"Try @nyaf"},{"location":"md/learn/#online-playgrounds","text":"If you\u2019re interested in playing around with @nyaf , you can use an online code playground. Try a Hello World template on CodePen, CodeSandbox, Glitch, or Stackblitz. If you prefer to use your own text editor, you can also download this HTML file, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation, so we\u2019d only recommend using this for simple demos.","title":"Online Playgrounds"},{"location":"md/learn/#add-nyaf-to-a-website","text":"You can add @nyaf to an HTML page in one minute. You can then either gradually expand its presence, or keep it contained to a few dynamic widgets.","title":"Add @nyaf to a Website"},{"location":"md/learn/#create-a-new-nyaf-app","text":"When starting a @nyaf project, a simple HTML page with script tags might still be the best option. It only takes a minute to set up! As your application grows, you might want to consider a more integrated setup. There are several JavaScript tool-chains we recommend for larger applications. Each of them can work with little to no configuration and lets you take full advantage of the rich @nyaf ecosystem. Learn how.","title":"Create a New @nyaf App"},{"location":"md/learn/#learning-strategies","text":"People come to @nyaf from different backgrounds and with different learning styles. Whether you prefer a more theoretical or a practical approach, we hope you\u2019ll find this section helpful. If you prefer to learn by doing, start with our practical tutorial. If you prefer to learn concepts step by step, start with our guide to main concepts. Like any unfamiliar technology, @nyaf does have a learning curve. With practice and some patience, you will get the hang of it.","title":"Learning Strategies"},{"location":"md/learn/#first-examples","text":"The @nyaf homepage contains a few small @nyaf examples with a live editor. Even if you don\u2019t know anything about @nyaf yet, try changing their code and see how it affects the result.","title":"First Examples"},{"location":"md/learn/#nyaf-for-beginners","text":"If you feel that the @nyaf documentation goes at a faster pace than you\u2019re comfortable with, check out this overview of @nyaf by Tania Rascia. It introduces the most important @nyaf concepts in a detailed, beginner-friendly way. Once you\u2019re done, give the documentation another try!","title":"@nyaf for Beginners"},{"location":"md/learn/#nyaf-for-designers","text":"If you\u2019re coming from a design background, these resources are a great place to get started.","title":"@nyaf for Designers"},{"location":"md/learn/#javascript-resources","text":"The @nyaf documentation assumes some familiarity with programming in the JavaScript language. You don\u2019t have to be an expert, but it\u2019s harder to learn both @nyaf and JavaScript at the same time. We recommend going through this JavaScript overview to check your knowledge level. It will take you between 30 minutes and an hour but you will feel more confident learning @nyaf . Tip: Whenever you get confused by something in JavaScript, MDN and javascript.info are great websites to check. There are also community support forums where you can ask for help.","title":"JavaScript Resources"},{"location":"md/learn/#practical-tutorial","text":"If you prefer to learn by doing, check out our practical tutorial. In this tutorial, we build a tic-tac-toe game in @nyaf . You might be tempted to skip it because you\u2019re not into building games \u2014 but give it a chance. The techniques you\u2019ll learn in the tutorial are fundamental to building any @nyaf apps, and mastering it will give you a much deeper understanding.","title":"Practical Tutorial"},{"location":"md/learn/#step-by-step-guide","text":"If you prefer to learn concepts step by step, our guide to main concepts is the best place to start. Every next chapter in it builds on the knowledge introduced in the previous chapters so you won\u2019t miss anything as you go along.","title":"Step-by-Step Guide"},{"location":"md/learn/#thinking-in-nyaf","text":"Many @nyaf users credit reading Thinking in @nyaf as the moment @nyaf finally \u201cclicked\u201d for them. It\u2019s probably the oldest @nyaf walk-through but it\u2019s still just as relevant.","title":"Thinking in @nyaf"},{"location":"md/learn/#recommended-courses","text":"Sometimes people find third-party books and video courses more helpful than the official documentation. We maintain a list of commonly recommended resources, some of which are free.","title":"Recommended Courses"},{"location":"md/learn/#advanced-concepts","text":"Once you\u2019re comfortable with the main concepts and played with @nyaf a little bit, you might be interested in more advanced topics. This section will introduce you to the powerful, but less commonly used @nyaf features like context and refs.","title":"Advanced Concepts"},{"location":"md/learn/#api-reference","text":"This documentation section is useful when you want to learn more details about a particular @nyaf API. For example, @nyaf .Component API reference can provide you with details on how setState() works, and what different lifecycle methods are useful for.","title":"API Reference"},{"location":"md/learn/#glossary-and-faq","text":"The glossary contains an overview of the most common terms you\u2019ll see in the @nyaf documentation. There is also a FAQ section dedicated to short questions and answers about common topics, including making AJAX requests, component state, and file structure.","title":"Glossary and FAQ"},{"location":"md/storybook/","text":"What is Storybook? # Creating an app can be hard if there is no structure. Storybook solves this by providing a graphical view on the component structure. Storybook about itself: : Storybook is a user interface development environment and playground for UI components. The tool enables developers to create components independently and showcase components interactively in an isolated development environment. Apart from all the other frameworks Storybook supports, there is a plugin that supports @nyaf very well.","title":"What is Storybook?"},{"location":"md/storybook/#what-is-storybook","text":"Creating an app can be hard if there is no structure. Storybook solves this by providing a graphical view on the component structure. Storybook about itself: : Storybook is a user interface development environment and playground for UI components. The tool enables developers to create components independently and showcase components interactively in an isolated development environment. Apart from all the other frameworks Storybook supports, there is a plugin that supports @nyaf very well.","title":"What is Storybook?"},{"location":"md/ts/","text":"Project Configuration with TypeScript # An @nyaf application consists of: An entry file for registering components, typically called main.ts At least one root component The index.html file the browser loads first The configuration for TypeScript, tsconfig.json The Packer / Builder setup; The best choice for a Packer is probably WebPack, in that case a webpack.config.js file is recommended. The Entry File # The recommended folder structure looks like this: code.txt { white-space: pre !important; } | \\--\\src | |-- index.html | |-- main.ts | \\-- \\components | | | | | \\-- main.component.tsx | | | \\-- \\assets | |-- webpack.config.js |-- tsconfig.json The application starts with the code in main.ts and the basics structure looks like Figure A-1. TypeScript Configuration # The TypeScript configuration is typical, but two things are crucial to know: You need to compile with the target \"es2015\" (minimum). ES 5 is explicitly not supported anymore. The template language is a variety of JSX, so the setting \"jsx\" and \"reactNamespace\" are required. @nyaf does not use React, has no relation to React and has almost nothing in common. The setting just tricks the compiler to transpile the templates. { \"compilerOptions\": { \"target\": \"es2015\", \"module\": \"commonjs\", \"moduleResolution\": \"node\", \"resolveJsonModule\": true, \"sourceMap\": true, \"lib\": [\"es2018\", \"es5\", \"dom\"], \"jsx\": \"react\", \"reactNamespace\": \"JSX\", \"declaration\": false, \"experimentalDecorators\": true, \"noImplicitAny\": false, \"suppressImplicitAnyIndexErrors\": true, \"removeComments\": false, \"outDir\": \"out-tsc\", \"baseUrl\": \"./src\", \"typeRoots\": [ \"node_modules/@types\", \"src/types\" ] }, \"files\": [\"./src/main.ts\"] } First, the target must be \"es2015\" or higher. There are some native features used here that don't have polyfills. The recommended template language is JSX (or in TypeScript it's called TSX). It's not enforced, you can also use pure string templates, but all examples in this documentation and the snippets shown online are using JSX. Hence the following settings are highly recommended: \"jsx\": \"react\" -- this activates JSX, though we don't use React \"reactNamespace\": \"JSX\" -- the name of the support class in @nyaf (this is mandatory if JSX is used) All other settings follow the common requirements of a typical TypeScript application. WebPack Configuration # WebPack is the recommended packer tool, but you can use any other if you like. There is no dependency. A typical configuration will look like this: const dev = process.env.NODE_ENV === 'dev'; const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); // Main entry point const indexConfig = { template: './src/index.html', inject: 'body', baseHref: './' }; const webpackConfig = { mode: 'development', // How source maps are generated : style of source mapping devtool: dev ? 'eval-cheap-module-source-map' : false, // Development server configuration devServer: { historyApiFallback: true, contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000 }, // Where webpack looks to start building the bundle entry: { 'app': './src/main.ts' // App entry point }, // How the different types of modules within // a project will be treated module: { rules: [ { test: /\\.ts|\\.tsx$/, loader: 'ts-loader' }, // All files with a '.scss' extension // will be handled by sass-loader { test: /\\.(scss)$/, use: [ 'style-loader', 'css-loader', 'sass-loader' ] }, { test: /\\.css$/, use: ['style-loader', 'css-loader'] }, { test: /\\.(png|jpeg)$/, loader: 'url-loader?limit=8192'}, { test: /\\.(woff|woff2)$/, loader: 'file-loader' } ] }, // Configure how modules are resolved resolve: { extensions: ['.ts', '.tsx', '.js', '.scss'] }, // How and where webpack should output // bundles, assets and anything else output: { path: path.resolve('./dist'), filename: '[name].js' }, // Customize the webpack build process with additional plugins plugins: [ new HtmlWebpackPlugin(indexConfig) ] }; // Export the config module.exports = webpackConfig; See the comments inline for important explanations. Apart from this the configuration has no special settings and follows the common rules of a typical WebPack setup.","title":"Project Configuration (TS)"},{"location":"md/ts/#project-configuration-with-typescript","text":"An @nyaf application consists of: An entry file for registering components, typically called main.ts At least one root component The index.html file the browser loads first The configuration for TypeScript, tsconfig.json The Packer / Builder setup; The best choice for a Packer is probably WebPack, in that case a webpack.config.js file is recommended.","title":"Project Configuration with TypeScript"},{"location":"md/ts/#the-entry-file","text":"The recommended folder structure looks like this: code.txt { white-space: pre !important; } | \\--\\src | |-- index.html | |-- main.ts | \\-- \\components | | | | | \\-- main.component.tsx | | | \\-- \\assets | |-- webpack.config.js |-- tsconfig.json The application starts with the code in main.ts and the basics structure looks like Figure A-1.","title":"The Entry File"},{"location":"md/ts/#typescript-configuration","text":"The TypeScript configuration is typical, but two things are crucial to know: You need to compile with the target \"es2015\" (minimum). ES 5 is explicitly not supported anymore. The template language is a variety of JSX, so the setting \"jsx\" and \"reactNamespace\" are required. @nyaf does not use React, has no relation to React and has almost nothing in common. The setting just tricks the compiler to transpile the templates. { \"compilerOptions\": { \"target\": \"es2015\", \"module\": \"commonjs\", \"moduleResolution\": \"node\", \"resolveJsonModule\": true, \"sourceMap\": true, \"lib\": [\"es2018\", \"es5\", \"dom\"], \"jsx\": \"react\", \"reactNamespace\": \"JSX\", \"declaration\": false, \"experimentalDecorators\": true, \"noImplicitAny\": false, \"suppressImplicitAnyIndexErrors\": true, \"removeComments\": false, \"outDir\": \"out-tsc\", \"baseUrl\": \"./src\", \"typeRoots\": [ \"node_modules/@types\", \"src/types\" ] }, \"files\": [\"./src/main.ts\"] } First, the target must be \"es2015\" or higher. There are some native features used here that don't have polyfills. The recommended template language is JSX (or in TypeScript it's called TSX). It's not enforced, you can also use pure string templates, but all examples in this documentation and the snippets shown online are using JSX. Hence the following settings are highly recommended: \"jsx\": \"react\" -- this activates JSX, though we don't use React \"reactNamespace\": \"JSX\" -- the name of the support class in @nyaf (this is mandatory if JSX is used) All other settings follow the common requirements of a typical TypeScript application.","title":"TypeScript Configuration"},{"location":"md/ts/#webpack-configuration","text":"WebPack is the recommended packer tool, but you can use any other if you like. There is no dependency. A typical configuration will look like this: const dev = process.env.NODE_ENV === 'dev'; const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); // Main entry point const indexConfig = { template: './src/index.html', inject: 'body', baseHref: './' }; const webpackConfig = { mode: 'development', // How source maps are generated : style of source mapping devtool: dev ? 'eval-cheap-module-source-map' : false, // Development server configuration devServer: { historyApiFallback: true, contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000 }, // Where webpack looks to start building the bundle entry: { 'app': './src/main.ts' // App entry point }, // How the different types of modules within // a project will be treated module: { rules: [ { test: /\\.ts|\\.tsx$/, loader: 'ts-loader' }, // All files with a '.scss' extension // will be handled by sass-loader { test: /\\.(scss)$/, use: [ 'style-loader', 'css-loader', 'sass-loader' ] }, { test: /\\.css$/, use: ['style-loader', 'css-loader'] }, { test: /\\.(png|jpeg)$/, loader: 'url-loader?limit=8192'}, { test: /\\.(woff|woff2)$/, loader: 'file-loader' } ] }, // Configure how modules are resolved resolve: { extensions: ['.ts', '.tsx', '.js', '.scss'] }, // How and where webpack should output // bundles, assets and anything else output: { path: path.resolve('./dist'), filename: '[name].js' }, // Customize the webpack build process with additional plugins plugins: [ new HtmlWebpackPlugin(indexConfig) ] }; // Export the config module.exports = webpackConfig; See the comments inline for important explanations. Apart from this the configuration has no special settings and follows the common rules of a typical WebPack setup.","title":"WebPack Configuration"},{"location":"md/docs/comparision/angular/","text":"@nyaf and Angular # Angular is a full-fledged framework that has an answer for everything. It comes with huge amount of code. The main reason to use Angular is to have a very powerful template language. It gives developers the feel they must not learn HTML 5 APIs and can still do anything by just learning Angular. That's true, but what the guys at Google not say is that the learning curve is extremely steep and it's a long way until you master Angular. Would you learn HTML 5 instead... but that's to easy, isn't it? Taking the Best # Angular comes with full support of TypeScript (actually, it's written in TypeScript) and all the new handy features, such as Decorators. That's the same as in @nyaf. Let's compare it a bit here. Components # A component in Angular is decorated with @Component({}) . It needs several settings, though. A component in @nyaf is quite the same, using @CustomElement('name') . Despite the name no additional settings required. Angular comes with a template language you have to learn. <ul> <li *ngFor=\"let item of items\" >{{ item.text }}</li> </ul> The part to learn is the very proprietary * ngFor instruction. Some JavaScript is possible here, but very restrictive. @nyaf comes with TSX, which is TypeScript with embedded HTML elements. Not so much to learn here. const lis = this.items.map(item => <li>{ item.text })</li>); <ul> { lis } </ul> There is nothing special, it's an array with a map function call. HTML remains \"as is\". You could even make it short like this: <ul> { this.items.map(item => <li>{ item.text })</li>) } </ul> However, in bigger components this could reduce the readability. But anyway, three lines of code against three lines of code. Any sort of JavaScript is allowed in here, as long as it fits into a function call. Binding # Angular has great data binding. @nyaf has this, too, but on request. Let's return to the last example. In Angular the list items will re-render if the collection items changes. That's smart and easy to use. It comes with a big penalty: Huge template compiler that inserts a lot boilerplate code for you. <div class=\"alert alert-danger\"> {{ message }} </div> Supporting steps required (component and binding property): @Component({ selector: 'app-demo', templateUrl: 'code-from-last-example.html' }) { public message: string; } That's smart, because it's easy to use. In @nyaf you load the module @nyaf/forms and use explicit binding: <div class=\"alert alert-danger\" n-bind={to<Messages>(m => m.message), 'innerText'}> </div> Supporting steps required (component and viewmodel): // create a viewmodel export class Messages { message: string; } @ViewModel<Messages>(Messages) @CustomElement('app-demo') export class AppDemoComponent { // component goes here } That's great because it has several advantages: Binding only if required The viewmodel approach is a better way to implement a \"separation of concerns\" pattern Full editor / IntelliSense support due to using TypeScript in the TSX syntax ({} braces) - without additional tooling or plug-ins Customizable binders to exactly what you need No memory footprint, there is no boilerplate code or generated stuff (it's a JavaScript native Proxy behind the scene)","title":"...Angular"},{"location":"md/docs/comparision/angular/#nyaf-and-angular","text":"Angular is a full-fledged framework that has an answer for everything. It comes with huge amount of code. The main reason to use Angular is to have a very powerful template language. It gives developers the feel they must not learn HTML 5 APIs and can still do anything by just learning Angular. That's true, but what the guys at Google not say is that the learning curve is extremely steep and it's a long way until you master Angular. Would you learn HTML 5 instead... but that's to easy, isn't it?","title":"@nyaf and Angular"},{"location":"md/docs/comparision/angular/#taking-the-best","text":"Angular comes with full support of TypeScript (actually, it's written in TypeScript) and all the new handy features, such as Decorators. That's the same as in @nyaf. Let's compare it a bit here.","title":"Taking the Best"},{"location":"md/docs/comparision/angular/#components","text":"A component in Angular is decorated with @Component({}) . It needs several settings, though. A component in @nyaf is quite the same, using @CustomElement('name') . Despite the name no additional settings required. Angular comes with a template language you have to learn. <ul> <li *ngFor=\"let item of items\" >{{ item.text }}</li> </ul> The part to learn is the very proprietary * ngFor instruction. Some JavaScript is possible here, but very restrictive. @nyaf comes with TSX, which is TypeScript with embedded HTML elements. Not so much to learn here. const lis = this.items.map(item => <li>{ item.text })</li>); <ul> { lis } </ul> There is nothing special, it's an array with a map function call. HTML remains \"as is\". You could even make it short like this: <ul> { this.items.map(item => <li>{ item.text })</li>) } </ul> However, in bigger components this could reduce the readability. But anyway, three lines of code against three lines of code. Any sort of JavaScript is allowed in here, as long as it fits into a function call.","title":"Components"},{"location":"md/docs/comparision/angular/#binding","text":"Angular has great data binding. @nyaf has this, too, but on request. Let's return to the last example. In Angular the list items will re-render if the collection items changes. That's smart and easy to use. It comes with a big penalty: Huge template compiler that inserts a lot boilerplate code for you. <div class=\"alert alert-danger\"> {{ message }} </div> Supporting steps required (component and binding property): @Component({ selector: 'app-demo', templateUrl: 'code-from-last-example.html' }) { public message: string; } That's smart, because it's easy to use. In @nyaf you load the module @nyaf/forms and use explicit binding: <div class=\"alert alert-danger\" n-bind={to<Messages>(m => m.message), 'innerText'}> </div> Supporting steps required (component and viewmodel): // create a viewmodel export class Messages { message: string; } @ViewModel<Messages>(Messages) @CustomElement('app-demo') export class AppDemoComponent { // component goes here } That's great because it has several advantages: Binding only if required The viewmodel approach is a better way to implement a \"separation of concerns\" pattern Full editor / IntelliSense support due to using TypeScript in the TSX syntax ({} braces) - without additional tooling or plug-ins Customizable binders to exactly what you need No memory footprint, there is no boilerplate code or generated stuff (it's a JavaScript native Proxy behind the scene)","title":"Binding"},{"location":"md/docs/comparision/polymer/","text":"Polymer Lit-Element # That's really close, but still - Polymer is a bit to restrictive concerning TypeScript. These guys over their like Babel to much. Components # See the entry example in Polymer form their docs: import { LitElement, html, property, customElement } from 'lit-element'; @customElement('simple-greeting') export class SimpleGreeting extends LitElement { @property() name = 'World'; render() { return html`<p>Hello, ${this.name}!</p>`; } } // Usage somewhere else in HTML <simple-greeting name=\"Everyone\"></simple-greeting> See the same in @nyaf: import { BaseComponent, CustomElement, Properties } from '@nyaf/lib'; @CustomElement('simple-greeting') @Properties({ name = 'World' }); export class SimpleGreeting extends BaseComponent<{ name: string }> { render() { return <p>Hello, {this.data.name}!</p>; } } // Usage somewhere else in HTML <simple-greeting name=\"Everyone\"></simple-greeting> As in React, Polymer's lit-element doesn't has any template features.","title":"...Polymer"},{"location":"md/docs/comparision/polymer/#polymer-lit-element","text":"That's really close, but still - Polymer is a bit to restrictive concerning TypeScript. These guys over their like Babel to much.","title":"Polymer Lit-Element"},{"location":"md/docs/comparision/polymer/#components","text":"See the entry example in Polymer form their docs: import { LitElement, html, property, customElement } from 'lit-element'; @customElement('simple-greeting') export class SimpleGreeting extends LitElement { @property() name = 'World'; render() { return html`<p>Hello, ${this.name}!</p>`; } } // Usage somewhere else in HTML <simple-greeting name=\"Everyone\"></simple-greeting> See the same in @nyaf: import { BaseComponent, CustomElement, Properties } from '@nyaf/lib'; @CustomElement('simple-greeting') @Properties({ name = 'World' }); export class SimpleGreeting extends BaseComponent<{ name: string }> { render() { return <p>Hello, {this.data.name}!</p>; } } // Usage somewhere else in HTML <simple-greeting name=\"Everyone\"></simple-greeting> As in React, Polymer's lit-element doesn't has any template features.","title":"Components"},{"location":"md/docs/comparision/preact/","text":"","title":"...Preact"},{"location":"md/docs/comparision/react/","text":"nyaf and React # Due to the nature of using TSX/JSX for templates it seems that React is quite close. But that's not entirely true. @nyaf has a lot to offer. Components # React is based on JavaScript and not native in TypeScript. That seems just a small issue, as TypeScript compiles down to JavaScript anyway, but in reality it's a big deal. Because of the non-native development style the TypeScript form is not very elegant. And the real advantage of TypeScript, such as advanced types like decorators and interfaces, are not or rarely used. Let's compare it. React # This is a simple component in React. The name always follows the class name, Welcome in this example. class Welcome extends BaseComponent<{}> { render() { return <h1>Hello, {this.props.name}</h1>; } } @nyaf # This is a simple component on @nyaf. The name is defined separately, and so is the property definition. Apart from this, it's the same. @CustomElement('app-welcome') @Properties({ name: '' }) class WelcomeComponent extends BaseComponent<{ name: string }> { render() { return <h1>Hello, {this.data.name}</h1>; } } The element style is more natural, because the browser engine processes the Web Components, not custom code. Because of the generic the editor will recognize and resolve the this.data property, too. Also, the render code allows async calls to pull data from a data source or do other non-blocking stuff. State # React documentation says: Never mutate this.state directly, as calling setState() afterwards may replace the mutation you made. Treat this.state as if it were immutable. In @nyaf it's a similar mechanism, but simpler. There is no distinguish between props and state, you define properties and held the state in it. There is no need to use the properties, then. That's why it's called data and purposefully setData() . However, you can set the state directly on the object and don't need to follow restrictions. It's a Proxy under the hat that handles the changes. If something isn't allows the property would be readonly and the editor shows this, no need to read documentation and remember it all the time. Events # In React a so-called synthetic event looks like this: <button onClick={activateLasers}> Activate Lasers </button> In @nyaf it's not that different: <button n-on-click={this.activateLasers}> Activate Lasers </button> The this quantifier is necessary. The main reason is that the code transforms directly into JavaScript and there is nothing \"synthetic\" here, the template engine connects the method as a dynamic handler directly to the event. However, you can use custom events that transport additional data. But still, it's the browsers event engine that handles these event natively. Conditions # See this example from the React documentation: function UserGreeting(props) { return <h1>Welcome back!</h1>; } function GuestGreeting(props) { return <h1>Please sign up.</h1>; } function Greeting(props) { const isLoggedIn = props.isLoggedIn; if (isLoggedIn) { return <UserGreeting />; } return <GuestGreeting />; } In @nyaf this would look a bit different. @CustomElement('user-greeting') export class UserGreeting extends BaseComponent<void> { constructor() { super(); } render() { return <h1>Welcome back!</h1>; } } @CustomElement('guest-greeting') export class GuestGreeting() extends BaseComponent<void> { constructor() { super(); } render() { return <h1>Please sign up.</h1>; } } @CustomElement('app-greeting') export class Greeting() extends BaseComponent<{ isLoggedIn: boolean}> { constructor() { super(); } render() { const isLoggedIn = this.data.isLoggedIn; return ( <user-greeting n-if={isLoggedIn} /> <guest-greeting n-if={!isLoggedIn} /> ); } It's a little more verbose, but it's easier to read due to additional template functions, here n-if . Lists # As far as it's just JSX the handling is the same in React and @nyaf. The key feature for rendering of list items according to element changes does not exist in @nyaf. The render engine will always render the whole list, if something changes. That's not that smart, but it reduces the template code drastically.","title":"...React"},{"location":"md/docs/comparision/react/#nyaf-and-react","text":"Due to the nature of using TSX/JSX for templates it seems that React is quite close. But that's not entirely true. @nyaf has a lot to offer.","title":"nyaf and React"},{"location":"md/docs/comparision/react/#components","text":"React is based on JavaScript and not native in TypeScript. That seems just a small issue, as TypeScript compiles down to JavaScript anyway, but in reality it's a big deal. Because of the non-native development style the TypeScript form is not very elegant. And the real advantage of TypeScript, such as advanced types like decorators and interfaces, are not or rarely used. Let's compare it.","title":"Components"},{"location":"md/docs/comparision/react/#react","text":"This is a simple component in React. The name always follows the class name, Welcome in this example. class Welcome extends BaseComponent<{}> { render() { return <h1>Hello, {this.props.name}</h1>; } }","title":"React"},{"location":"md/docs/comparision/react/#nyaf","text":"This is a simple component on @nyaf. The name is defined separately, and so is the property definition. Apart from this, it's the same. @CustomElement('app-welcome') @Properties({ name: '' }) class WelcomeComponent extends BaseComponent<{ name: string }> { render() { return <h1>Hello, {this.data.name}</h1>; } } The element style is more natural, because the browser engine processes the Web Components, not custom code. Because of the generic the editor will recognize and resolve the this.data property, too. Also, the render code allows async calls to pull data from a data source or do other non-blocking stuff.","title":"@nyaf"},{"location":"md/docs/comparision/react/#state","text":"React documentation says: Never mutate this.state directly, as calling setState() afterwards may replace the mutation you made. Treat this.state as if it were immutable. In @nyaf it's a similar mechanism, but simpler. There is no distinguish between props and state, you define properties and held the state in it. There is no need to use the properties, then. That's why it's called data and purposefully setData() . However, you can set the state directly on the object and don't need to follow restrictions. It's a Proxy under the hat that handles the changes. If something isn't allows the property would be readonly and the editor shows this, no need to read documentation and remember it all the time.","title":"State"},{"location":"md/docs/comparision/react/#events","text":"In React a so-called synthetic event looks like this: <button onClick={activateLasers}> Activate Lasers </button> In @nyaf it's not that different: <button n-on-click={this.activateLasers}> Activate Lasers </button> The this quantifier is necessary. The main reason is that the code transforms directly into JavaScript and there is nothing \"synthetic\" here, the template engine connects the method as a dynamic handler directly to the event. However, you can use custom events that transport additional data. But still, it's the browsers event engine that handles these event natively.","title":"Events"},{"location":"md/docs/comparision/react/#conditions","text":"See this example from the React documentation: function UserGreeting(props) { return <h1>Welcome back!</h1>; } function GuestGreeting(props) { return <h1>Please sign up.</h1>; } function Greeting(props) { const isLoggedIn = props.isLoggedIn; if (isLoggedIn) { return <UserGreeting />; } return <GuestGreeting />; } In @nyaf this would look a bit different. @CustomElement('user-greeting') export class UserGreeting extends BaseComponent<void> { constructor() { super(); } render() { return <h1>Welcome back!</h1>; } } @CustomElement('guest-greeting') export class GuestGreeting() extends BaseComponent<void> { constructor() { super(); } render() { return <h1>Please sign up.</h1>; } } @CustomElement('app-greeting') export class Greeting() extends BaseComponent<{ isLoggedIn: boolean}> { constructor() { super(); } render() { const isLoggedIn = this.data.isLoggedIn; return ( <user-greeting n-if={isLoggedIn} /> <guest-greeting n-if={!isLoggedIn} /> ); } It's a little more verbose, but it's easier to read due to additional template functions, here n-if .","title":"Conditions"},{"location":"md/docs/comparision/react/#lists","text":"As far as it's just JSX the handling is the same in React and @nyaf. The key feature for rendering of list items according to element changes does not exist in @nyaf. The render engine will always render the whole list, if something changes. That's not that smart, but it reduces the template code drastically.","title":"Lists"},{"location":"md/docs/comparision/stencil/","text":"","title":"...Stencil"},{"location":"md/docs/comparision/svelte/","text":"","title":"...Svelte"},{"location":"md/docs/comparision/vue/","text":"","title":"...Vue"},{"location":"md/docs/forms/custombinders/","text":"Custom Binders # Custom Binders help binding to specific properties. They can be used like the embedded binders, that act just as examples and use the same way. Implementing a Custom Binder # A custom binder handles the binding procedure when binding a viewmodel property to an element attribute. It consists of three parts: The binding setup ( bind ) The binder into the element (a property change leads to an attribute change) The listener (an attribute change event leads to an updated model property) Step 2 and 3 are both optional, omitting them is leading to a uni-directional binding in one or another direction. @BindName('VisibilityBinder') export class VisibilityBinder<T extends ConfirmSuccessErrorComponent> implements IBindingHandler { bind(binding: Binding): void { (binding.el as T).addEventListener('done', (e) => { this.listener(binding, e); }) this.react(binding); } react(binding: Binding): void { (binding.el as T).visibility = !!binding.value; } listener(binding: Binding): void { const value = (binding.el as T).visibility; binding.value = value; } } Note here, that despite the base class the decorator @BindName is required. The argument is the name of the class. In the views' code the binder class' name can be used to determine the behavior. But in case the project is packed by an aggressive packer, the names of the classes might be minified. The code compares the names and due to different minification steps it could happen that the comparison fails. The decorator writes the name into an internal property and the compare code can retrieve this properly. If the view code uses strings instead of types, using this decorator is not necessary. How it Works # First, you need to implement IBindingHandler . export interface IBindingHandler { bind?(binding: Binding | ValidatorBinding): void; react(binding: Binding | ValidatorBinding, property?: string): void; listener?(binding: Binding | ValidatorBinding, e?: Event): void; } A handler must react to something, but everything else is optional. See this line: export class VisibilityHandler<T extends ConfirmComponent> implements IBindingHandler The generic is optional. It allows the definition of the target element. If it's omitted, it falls back to HTMLElement . You can use any HTML 5 element type or any custom web component type (as in the example). The bind method is called implicitly by the infrastructure. If it doesn't exist it's being ignored. The only reason to use it is attaching an event listener. You may also consider calling react immediately to sync the data, but it depends on the actual behavior of the element and may result in an additional binding process while loading the form. The method react is called from the view model proxy instance each time the value changes. Write code here to assign the data to any property of the target element. The method listener is optional and is called once the target element raises an event. You can access the original event if provided. A Simple Binder # How simple a binder can be is shown next with the already embedded uni-directional default binder: @BindName('DefaultBindingHandler') export class DefaultBindingHandler implements IBindingHandler { react(binding: Binding, property: string): void { binding.el[property] = binding.value; } } The only difference here is that the ModelBinder class intercepts the access and delivers the name of the attribute as a second parameter. This is a special behavior and the default handler can handle this. Note that all examples have almost no error and exception handling. Add this if you want a more robust application.","title":"Custom Binders"},{"location":"md/docs/forms/custombinders/#custom-binders","text":"Custom Binders help binding to specific properties. They can be used like the embedded binders, that act just as examples and use the same way.","title":"Custom Binders"},{"location":"md/docs/forms/custombinders/#implementing-a-custom-binder","text":"A custom binder handles the binding procedure when binding a viewmodel property to an element attribute. It consists of three parts: The binding setup ( bind ) The binder into the element (a property change leads to an attribute change) The listener (an attribute change event leads to an updated model property) Step 2 and 3 are both optional, omitting them is leading to a uni-directional binding in one or another direction. @BindName('VisibilityBinder') export class VisibilityBinder<T extends ConfirmSuccessErrorComponent> implements IBindingHandler { bind(binding: Binding): void { (binding.el as T).addEventListener('done', (e) => { this.listener(binding, e); }) this.react(binding); } react(binding: Binding): void { (binding.el as T).visibility = !!binding.value; } listener(binding: Binding): void { const value = (binding.el as T).visibility; binding.value = value; } } Note here, that despite the base class the decorator @BindName is required. The argument is the name of the class. In the views' code the binder class' name can be used to determine the behavior. But in case the project is packed by an aggressive packer, the names of the classes might be minified. The code compares the names and due to different minification steps it could happen that the comparison fails. The decorator writes the name into an internal property and the compare code can retrieve this properly. If the view code uses strings instead of types, using this decorator is not necessary.","title":"Implementing a Custom Binder"},{"location":"md/docs/forms/custombinders/#how-it-works","text":"First, you need to implement IBindingHandler . export interface IBindingHandler { bind?(binding: Binding | ValidatorBinding): void; react(binding: Binding | ValidatorBinding, property?: string): void; listener?(binding: Binding | ValidatorBinding, e?: Event): void; } A handler must react to something, but everything else is optional. See this line: export class VisibilityHandler<T extends ConfirmComponent> implements IBindingHandler The generic is optional. It allows the definition of the target element. If it's omitted, it falls back to HTMLElement . You can use any HTML 5 element type or any custom web component type (as in the example). The bind method is called implicitly by the infrastructure. If it doesn't exist it's being ignored. The only reason to use it is attaching an event listener. You may also consider calling react immediately to sync the data, but it depends on the actual behavior of the element and may result in an additional binding process while loading the form. The method react is called from the view model proxy instance each time the value changes. Write code here to assign the data to any property of the target element. The method listener is optional and is called once the target element raises an event. You can access the original event if provided.","title":"How it Works"},{"location":"md/docs/forms/custombinders/#a-simple-binder","text":"How simple a binder can be is shown next with the already embedded uni-directional default binder: @BindName('DefaultBindingHandler') export class DefaultBindingHandler implements IBindingHandler { react(binding: Binding, property: string): void { binding.el[property] = binding.value; } } The only difference here is that the ModelBinder class intercepts the access and delivers the name of the attribute as a second parameter. This is a special behavior and the default handler can handle this. Note that all examples have almost no error and exception handling. Add this if you want a more robust application.","title":"A Simple Binder"},{"location":"md/docs/forms/nbind/","text":"Data Binding # Data Binding is one of the most important features in component development. It brings an immediate effect in simplifying the data presentation layer. Instead of the chain \"select\" --> \"set\" --> \"listen\" --> \"change\" you simply bind an object's properties to an element's attributes. That could go in both directions. Template Language Enhancements # @nyaf has a simple template language extension for binding. For forms it's just one more command for any input element, n-bind . See the following excerpt from a component. model: ModelBinder<UserViewModel>; // instance created by decorator render() { const model: UserViewModel = new UserViewModel(); // or where ever the model comes from return ( <> <form> <input n-bind=\"value: Name\" /> </form> </>); } Now the field knows everything about how to render and how to validate. The first item (\"value\") is the HTML element's property you bind to. The second is the model's property name (\"Name\"). For a good UI you need a label usually: <label n-bind=\"innerText: userName\" /> Terms and Parts # To understand the binding you must know what a view model is and what role the model plays inside the form. View Model # The actual definition of the model that is bindable is provided through the decorator @ViewModel(T) . T is a type (class) that has properties decorated with validation and UI decorators. More about this can be found in chapter View Models . IModel interface # The @ViewModel decorator creates an instance of the model class. The interface enforces the visibility of the model in the component. The definition is quite easy: export interface IModel<VM extends object> { model: ModelBinder<VM>; } The instance of the modelbinder gives access to all binding features. Binding Handlers # Binding Handlers are small function calls that handle the data flow between viewmodel property and element attribute. There a few default binding handlers available. Smart Binders # Instead of using the string form you can use the TSX syntax and binding functions: to : Generic function to bind a property to the default attribute using a custom binder optionally. bind : Generic function to bind a property to any attribute. val : Bind validation decorators to an attribute. See validation . See in Section Smart Binders for details. Creating Forms # The model is provided by the @ViewModel decorator and the IModel<T> interface like this: @ViewModel(ModelType) export class component extends BaseComponent<any> implements IModel<ModelType> { render() { return ( <form> <label n-bind=\"innerText: userName\" for=\"un\"/> <input n-bind=\"value: userName\" id=\"un\" /> <br /> <label n-bind=\"innerText: city\" for=\"city\"/> <input n-bind=\"value: city\" id =\"city\" /> </form> ) } } The form now binds the data. It's bi-directional or uni-directional depending on the chosen binding handler. Standard Binding Handlers # The forms module comes with a couple of pre-defined binding handlers: Name Key Direction Applies to Base Element Default... 'default' uni attribute HTMLElement Checked... 'checked' bi attribute checked HTMLInputElement Text... 'innerText' uni property textContent HTMLElement Value... 'value' bi attribute value HTMLInputElement Visibility... 'visibility' uni style visibility HTMLElement Display... 'display' uni style display HTMLElement The actual handler names are XXXBindingHandler ( Default... is actually DefaultBindingHandler ). If in the binding attribute the text form is being used ('innerText: userName'), the key value determines the used handler. The handler provides the active code that handles the change call and applies the changed value to the right target property. That can be any property the element type supports, directly or indirectly anywhere in the object structure. Such a deeper call happens in the style handlers, especially VisibilityBindingHandler and DisplayBindingHandler . Smart Binders # There is an alternative syntax that provides full type support: <label n-bind={to<ContactModel>(c => c.email, 'innerText', Display)}> </label> The function to<Type> from @nyaf/forms module has these syntax variations: to<ViewModel>(propertyExpression, handlerKey) to<ViewModel>(propertyExpression, BindingHandlerType) to<ViewModel, ElementType>(propertyExpression, handlerKey) to<ViewModel, ElementType>(propertyExpression, BindingHandlerType) to<ViewModel>(propertyExpression, handlerKey, UIDecoratorType) to<ViewModel>(propertyExpression, BindingHandlerType, UIDecoratorType) to<ViewModel, ElementType>(propertyExpression, handlerKey, UIDecoratorType) to<ViewModel, ElementType>(propertyExpression, BindingHandlerType, UIDecoratorType) The generic parameters are as follows: The view model type. This is mandatory. The element type. This is optional, if omitted it falls back to HTMLElement . The parameters are as follows: A lambda expression to select a property type safe ( c => c.name ). This is mandatory. The key of a binding handler. Any property available in HTMLElement is allowed (and it's restricted to these). The (optional) type of decorator that's used to pull data from. If it's omitted, the actual data appear. Obviously you could think about writing this: <input n-bind={to<ContactModel>(c => c.email, 'value')} /> This is rejected by the compiler, because the property value doesn't exists in HTMLElement . To provide another type, just use a second generic type parameter: <input n-bind={to<ContactModel, HTMLInputElement>(c => c.email, 'value')} /> Here you tell the compiler, that it's safe to use HTMLInputElement and so the editor allows value as the second parameter. An even smarter way is to use the lambda here, too: <input n-bind={to<ContactModel, HTMLInputElement>(c => c.email, c => c.value)} /> But, both ways are type safe, even the string is following a constrain. The string is usually shorter, the lambda might use an earlier suggestion from Intellisense. The binding behavior is tricky but powerful. The intention is to provide rock solid type safety. You must provide an element attribute that really exists to make a successful binding. Everything else wouldn't make any sense. But to actually bind properly, you must provide a Binding Handler that can handle this particular binding. Multi Attribute Binding # The n-bind attribute is exclusive, so you can bind only one attribute. That's fine for most cases, but sometimes you'll need multiple bindings. In Angular this is easy through the binding syntax around any element ( <input [type]=\"source\" [value]=\"model\"> ). However, this would require a template compiler and additional editor support. To overcome the limitations here, the bind function is available. In the next example two properties are bound: <input value={bind<T>(c => c.email)} type={bind<T>(c => c.toggleType)} n-bind /> The n-bind is still required to efficiently trigger the binder logic. It's now empty, though (default value is true internally). Please note that you cannot bind to deeper structures in the current version (e.g. style.border={bind<T>()} is not possible.) That's typically a way to bind styles in Angular, but this would violate the rule that standard @nyaf templates shall be standard TSX files that any editor can handle without additional tool support. To support a scenario with style binding, refer to section Custom Binders . If the binding handler is not provided, it falls back to a DefaultBindingHandler , that binds uni-directional to the assigned attribute. That has two limitations. First, it's always uni-directional. Second, it can bind only to attributes of HTMLElement . Object properties, such as textContent or innerText cannot be reached that way. That's indeed the same with Angular, where you need to encapsulate elements in custom components to reach hidden properties, but in @nyaf there is a much smarter way. Imagine you'll bind to whatever, just assign another binding handler. <input value={bind<T>(c => c.email, ValueBindingHandler)} n-bind /> The binding handler may write into whatever property you like, even those not available as attributes. See section Custom Binders for more details. Even More Smartness # You may also define your component as a generic. That avoids repeating the model name over and over again. Imagine this: // ContactModel defined elsewhere export class ContactComponent<T extends ContactModel> extends BaseComponent<any> implements IModel<ContactModel> { And in that case use a shorter form to express the binding: <label n-bind={to<T>(c => c.email, c => c.innerText)} /> T is a placeholder here. Use any name you like to define a \"type\". That's cool, isn't it? Now we have a fully type safe binding definition in the middle of the TSX part without any additions to regular HTML. And in case you have special properties beyond HTMLElement , than just provide the proper type like you did before: <input n-bind={to<T, HTMLInputElement>(c => c.email, c => c.value)} /> This gives full type support in any editor for all types, even custom Web Components will work here. This technique avoids parsing the template, and the missing parser makes the package so small. The function simply returns a magic string that the model binder class recognizes at runtime. The function call with a generic helps the editor to understand the types and avoids mistakes.","title":"Data Binding"},{"location":"md/docs/forms/nbind/#data-binding","text":"Data Binding is one of the most important features in component development. It brings an immediate effect in simplifying the data presentation layer. Instead of the chain \"select\" --> \"set\" --> \"listen\" --> \"change\" you simply bind an object's properties to an element's attributes. That could go in both directions.","title":"Data Binding"},{"location":"md/docs/forms/nbind/#template-language-enhancements","text":"@nyaf has a simple template language extension for binding. For forms it's just one more command for any input element, n-bind . See the following excerpt from a component. model: ModelBinder<UserViewModel>; // instance created by decorator render() { const model: UserViewModel = new UserViewModel(); // or where ever the model comes from return ( <> <form> <input n-bind=\"value: Name\" /> </form> </>); } Now the field knows everything about how to render and how to validate. The first item (\"value\") is the HTML element's property you bind to. The second is the model's property name (\"Name\"). For a good UI you need a label usually: <label n-bind=\"innerText: userName\" />","title":"Template Language Enhancements"},{"location":"md/docs/forms/nbind/#terms-and-parts","text":"To understand the binding you must know what a view model is and what role the model plays inside the form.","title":"Terms and Parts"},{"location":"md/docs/forms/nbind/#view-model","text":"The actual definition of the model that is bindable is provided through the decorator @ViewModel(T) . T is a type (class) that has properties decorated with validation and UI decorators. More about this can be found in chapter View Models .","title":"View Model"},{"location":"md/docs/forms/nbind/#imodel-interface","text":"The @ViewModel decorator creates an instance of the model class. The interface enforces the visibility of the model in the component. The definition is quite easy: export interface IModel<VM extends object> { model: ModelBinder<VM>; } The instance of the modelbinder gives access to all binding features.","title":"IModel interface"},{"location":"md/docs/forms/nbind/#binding-handlers","text":"Binding Handlers are small function calls that handle the data flow between viewmodel property and element attribute. There a few default binding handlers available.","title":"Binding Handlers"},{"location":"md/docs/forms/nbind/#smart-binders","text":"Instead of using the string form you can use the TSX syntax and binding functions: to : Generic function to bind a property to the default attribute using a custom binder optionally. bind : Generic function to bind a property to any attribute. val : Bind validation decorators to an attribute. See validation . See in Section Smart Binders for details.","title":"Smart Binders"},{"location":"md/docs/forms/nbind/#creating-forms","text":"The model is provided by the @ViewModel decorator and the IModel<T> interface like this: @ViewModel(ModelType) export class component extends BaseComponent<any> implements IModel<ModelType> { render() { return ( <form> <label n-bind=\"innerText: userName\" for=\"un\"/> <input n-bind=\"value: userName\" id=\"un\" /> <br /> <label n-bind=\"innerText: city\" for=\"city\"/> <input n-bind=\"value: city\" id =\"city\" /> </form> ) } } The form now binds the data. It's bi-directional or uni-directional depending on the chosen binding handler.","title":"Creating Forms"},{"location":"md/docs/forms/nbind/#standard-binding-handlers","text":"The forms module comes with a couple of pre-defined binding handlers: Name Key Direction Applies to Base Element Default... 'default' uni attribute HTMLElement Checked... 'checked' bi attribute checked HTMLInputElement Text... 'innerText' uni property textContent HTMLElement Value... 'value' bi attribute value HTMLInputElement Visibility... 'visibility' uni style visibility HTMLElement Display... 'display' uni style display HTMLElement The actual handler names are XXXBindingHandler ( Default... is actually DefaultBindingHandler ). If in the binding attribute the text form is being used ('innerText: userName'), the key value determines the used handler. The handler provides the active code that handles the change call and applies the changed value to the right target property. That can be any property the element type supports, directly or indirectly anywhere in the object structure. Such a deeper call happens in the style handlers, especially VisibilityBindingHandler and DisplayBindingHandler .","title":"Standard Binding Handlers"},{"location":"md/docs/forms/nbind/#smart-binders_1","text":"There is an alternative syntax that provides full type support: <label n-bind={to<ContactModel>(c => c.email, 'innerText', Display)}> </label> The function to<Type> from @nyaf/forms module has these syntax variations: to<ViewModel>(propertyExpression, handlerKey) to<ViewModel>(propertyExpression, BindingHandlerType) to<ViewModel, ElementType>(propertyExpression, handlerKey) to<ViewModel, ElementType>(propertyExpression, BindingHandlerType) to<ViewModel>(propertyExpression, handlerKey, UIDecoratorType) to<ViewModel>(propertyExpression, BindingHandlerType, UIDecoratorType) to<ViewModel, ElementType>(propertyExpression, handlerKey, UIDecoratorType) to<ViewModel, ElementType>(propertyExpression, BindingHandlerType, UIDecoratorType) The generic parameters are as follows: The view model type. This is mandatory. The element type. This is optional, if omitted it falls back to HTMLElement . The parameters are as follows: A lambda expression to select a property type safe ( c => c.name ). This is mandatory. The key of a binding handler. Any property available in HTMLElement is allowed (and it's restricted to these). The (optional) type of decorator that's used to pull data from. If it's omitted, the actual data appear. Obviously you could think about writing this: <input n-bind={to<ContactModel>(c => c.email, 'value')} /> This is rejected by the compiler, because the property value doesn't exists in HTMLElement . To provide another type, just use a second generic type parameter: <input n-bind={to<ContactModel, HTMLInputElement>(c => c.email, 'value')} /> Here you tell the compiler, that it's safe to use HTMLInputElement and so the editor allows value as the second parameter. An even smarter way is to use the lambda here, too: <input n-bind={to<ContactModel, HTMLInputElement>(c => c.email, c => c.value)} /> But, both ways are type safe, even the string is following a constrain. The string is usually shorter, the lambda might use an earlier suggestion from Intellisense. The binding behavior is tricky but powerful. The intention is to provide rock solid type safety. You must provide an element attribute that really exists to make a successful binding. Everything else wouldn't make any sense. But to actually bind properly, you must provide a Binding Handler that can handle this particular binding.","title":"Smart Binders"},{"location":"md/docs/forms/nbind/#multi-attribute-binding","text":"The n-bind attribute is exclusive, so you can bind only one attribute. That's fine for most cases, but sometimes you'll need multiple bindings. In Angular this is easy through the binding syntax around any element ( <input [type]=\"source\" [value]=\"model\"> ). However, this would require a template compiler and additional editor support. To overcome the limitations here, the bind function is available. In the next example two properties are bound: <input value={bind<T>(c => c.email)} type={bind<T>(c => c.toggleType)} n-bind /> The n-bind is still required to efficiently trigger the binder logic. It's now empty, though (default value is true internally). Please note that you cannot bind to deeper structures in the current version (e.g. style.border={bind<T>()} is not possible.) That's typically a way to bind styles in Angular, but this would violate the rule that standard @nyaf templates shall be standard TSX files that any editor can handle without additional tool support. To support a scenario with style binding, refer to section Custom Binders . If the binding handler is not provided, it falls back to a DefaultBindingHandler , that binds uni-directional to the assigned attribute. That has two limitations. First, it's always uni-directional. Second, it can bind only to attributes of HTMLElement . Object properties, such as textContent or innerText cannot be reached that way. That's indeed the same with Angular, where you need to encapsulate elements in custom components to reach hidden properties, but in @nyaf there is a much smarter way. Imagine you'll bind to whatever, just assign another binding handler. <input value={bind<T>(c => c.email, ValueBindingHandler)} n-bind /> The binding handler may write into whatever property you like, even those not available as attributes. See section Custom Binders for more details.","title":"Multi Attribute Binding"},{"location":"md/docs/forms/nbind/#even-more-smartness","text":"You may also define your component as a generic. That avoids repeating the model name over and over again. Imagine this: // ContactModel defined elsewhere export class ContactComponent<T extends ContactModel> extends BaseComponent<any> implements IModel<ContactModel> { And in that case use a shorter form to express the binding: <label n-bind={to<T>(c => c.email, c => c.innerText)} /> T is a placeholder here. Use any name you like to define a \"type\". That's cool, isn't it? Now we have a fully type safe binding definition in the middle of the TSX part without any additions to regular HTML. And in case you have special properties beyond HTMLElement , than just provide the proper type like you did before: <input n-bind={to<T, HTMLInputElement>(c => c.email, c => c.value)} /> This gives full type support in any editor for all types, even custom Web Components will work here. This technique avoids parsing the template, and the missing parser makes the package so small. The function simply returns a magic string that the model binder class recognizes at runtime. The function call with a generic helps the editor to understand the types and avoids mistakes.","title":"Even More Smartness"},{"location":"md/docs/forms/overview/","text":"Forms Module # Forms provide these basic features: UI control decorators (example: @Hidden() to suppress a property in a dynamic table). Validation decorators (example: @MinLength(50) or @Required() to manage form validation). Data Binding using a model declaration decorator called @ViewModel and a bind attribute named n-bind . Form validation is a key part of any project. However, CSS frameworks require different strategies to handle errors and so on. Hence, the @nyaf/forms library provides a simple way (just like a skeleton) to give you the direction, but the actual validation implementation logic is up to you to build. Same for the UI decorators. It's a convenient way to add hidden properties to viewmodels. There is no logic to read these values, this is up to you to implement this. However, the decorators makes your life a lot easier. The binding logic is almost complete and once you have a decorated model it's syncing the UI automagically. How it Works # For full support you need view models, the registration on top of the component, and access to the model binder. View models are plain TypeScript classes with public properties enhanced by decorators. The registration with the decorator @ViewModel() on top of the component's class. The modelbinder comes through implementing the interface IModel<ViewModelType> . View Models in Components # For a nice looking view some decorators applied to class properties control the appearance. Use the decorator @ViewModel<T>(T) to define the model. The generic is the type, the constructor parameter defines the default values (it's mandatory ). To get access to the model binder, just implement the interface IModel as show below: export class Model { @Hidden() id: number = 0; @Required() name: string = ''; } @CustomElement('app-main') @ViewModel<Model>(Model) export class MainComponent extends BaseComponent<{}> implements IModel<Model> { // ... omitted for brevity } Within the component, the model binder is present through the property this.model . That's the only property and it's added automatically by the decorator. The interface just helps the TypeScript transpiler to understand tha property exists. this.model. ...// do something with it An actual object is already assigned to the property by a so called model binder. At any time, in the constructor, in load life cycle, or anytime later on user action you can add a new model if you need. That's a rare condition, though. Use this code, then: this.model.scope = new Model(); However, the @ViewModel decorator is doing exactly this for you, so in case of a new blank instance there is no need to assign a new object to the scope property. It's not necessary to keep a reference to the instance, the model binder is doing this internally for you. The derived class is a Proxy . If you now bind the properties using n-bind as described below, the model is in sync with the user interface. If you want to programmatically access the current state, just retrieve the model: let userName: string = this.model.scope.userName; If you wish to access the Proxy at any time in code or not using the binding in templates, this would be sufficient: private modelProxy: Model; constructor() { super(); this.modelProxy = this.model.scope; } The setter of scope takes an instance, wraps this into a Proxy , assigns the binders, and the getter returns the Proxy . Changes to the model will now reflect in bound HTML elements immediately. let userName: string = 'Test'; this.model.scope.userName = userName; // immediately invoke binders","title":"Overview"},{"location":"md/docs/forms/overview/#forms-module","text":"Forms provide these basic features: UI control decorators (example: @Hidden() to suppress a property in a dynamic table). Validation decorators (example: @MinLength(50) or @Required() to manage form validation). Data Binding using a model declaration decorator called @ViewModel and a bind attribute named n-bind . Form validation is a key part of any project. However, CSS frameworks require different strategies to handle errors and so on. Hence, the @nyaf/forms library provides a simple way (just like a skeleton) to give you the direction, but the actual validation implementation logic is up to you to build. Same for the UI decorators. It's a convenient way to add hidden properties to viewmodels. There is no logic to read these values, this is up to you to implement this. However, the decorators makes your life a lot easier. The binding logic is almost complete and once you have a decorated model it's syncing the UI automagically.","title":"Forms Module"},{"location":"md/docs/forms/overview/#how-it-works","text":"For full support you need view models, the registration on top of the component, and access to the model binder. View models are plain TypeScript classes with public properties enhanced by decorators. The registration with the decorator @ViewModel() on top of the component's class. The modelbinder comes through implementing the interface IModel<ViewModelType> .","title":"How it Works"},{"location":"md/docs/forms/overview/#view-models-in-components","text":"For a nice looking view some decorators applied to class properties control the appearance. Use the decorator @ViewModel<T>(T) to define the model. The generic is the type, the constructor parameter defines the default values (it's mandatory ). To get access to the model binder, just implement the interface IModel as show below: export class Model { @Hidden() id: number = 0; @Required() name: string = ''; } @CustomElement('app-main') @ViewModel<Model>(Model) export class MainComponent extends BaseComponent<{}> implements IModel<Model> { // ... omitted for brevity } Within the component, the model binder is present through the property this.model . That's the only property and it's added automatically by the decorator. The interface just helps the TypeScript transpiler to understand tha property exists. this.model. ...// do something with it An actual object is already assigned to the property by a so called model binder. At any time, in the constructor, in load life cycle, or anytime later on user action you can add a new model if you need. That's a rare condition, though. Use this code, then: this.model.scope = new Model(); However, the @ViewModel decorator is doing exactly this for you, so in case of a new blank instance there is no need to assign a new object to the scope property. It's not necessary to keep a reference to the instance, the model binder is doing this internally for you. The derived class is a Proxy . If you now bind the properties using n-bind as described below, the model is in sync with the user interface. If you want to programmatically access the current state, just retrieve the model: let userName: string = this.model.scope.userName; If you wish to access the Proxy at any time in code or not using the binding in templates, this would be sufficient: private modelProxy: Model; constructor() { super(); this.modelProxy = this.model.scope; } The setter of scope takes an instance, wraps this into a Proxy , assigns the binders, and the getter returns the Proxy . Changes to the model will now reflect in bound HTML elements immediately. let userName: string = 'Test'; this.model.scope.userName = userName; // immediately invoke binders","title":"View Models in Components"},{"location":"md/docs/forms/setup/","text":"Installation of Forms Module # Install the package: npm i @nyaf/forms -S The type definitions required for TypeScript are part of the packages and no additional type libraries are required. Dependencies # This packages depends on @nyaf/lib only.","title":"Setup"},{"location":"md/docs/forms/setup/#installation-of-forms-module","text":"Install the package: npm i @nyaf/forms -S The type definitions required for TypeScript are part of the packages and no additional type libraries are required.","title":"Installation of Forms Module"},{"location":"md/docs/forms/setup/#dependencies","text":"This packages depends on @nyaf/lib only.","title":"Dependencies"},{"location":"md/docs/forms/validation/","text":"Validation # Form validation is painful to programm from scratch. @nyaf/forms provides a n integrated but flexible validation system. View Model Decorators # First, you need a viewmodel that has validation decorators. It's the same kind of model used for regular binding. Again, here is an example: export class UserViewModel { @Hidden() id: Number = 0; @Display('E-Mail', 'E-Mail address') @Required() @MaxLength(100) @Email() email: string = ''; @Display('Phone Number', \"The user's phone\") @Required('Please, the phone number is required') @MaxLength(20) phoneNumber: string = ''; @Display('User Name', 'The full name') @Required() @MaxLength(100) userName: string = ''; } Especially the validation decorators are in control of the validation ( Required , MaxLength , and so on). In binding instruction you tell the environment with what decorator a property has to be connected. State # The validation state is available through state : this.model.state = { isValid: boolean, isPresent: boolean, errors: { [key: string]: string }, model: Model } It's supervised. After the component is rendered the property this.model.state helds the state of the model. After a binding happens the validators are being executed and the instance values change. You can retrieve the values in a method, or an event handler. To set UI elements interactively, immediately, you again use the n-bind attribute and the appropriate binding function like to and bind . Bind to Validators # An error message is just regular output (the class values are taken from Bootstrap and they're not needed by the @nyaf/forms module): <form> <label n-bind=\"innerText: userName\" for=\"un\"/> <input n-bind=\"value: userName\" id=\"un\"> <div class=\"text text-danger\" n-bind={val<ViewModel>(e => e.userName, Required, DisplayBindingHandler)}> </div> </form> Validators can provide the error text, too. This is driven by decorators. The decorators fall back to a simple plain english error message in case you don't provide anything. You can, however, provide any kind of message in the decorator. In case you need i18n messages, just add the @Translate decorator as a parameter decorator to the message parameter. Distinguish between different validators like this: <form> <label n-bind=\"innerText: userName\" for=\"un\"/> <input n-bind=\"value: userName\" id=\"un\"> <span class=\"text text-danger\" n-bind={val<ViewModel>(e => e.userName, MaxLength, DisplayBindingHandler)}> </span> </form> The smart binder val is the key ingredient here. It takes three parameters: An expression to access the models actual value. A validator for which the binding is responsible (must also be aon the view models property). A display handler, that pulls the values and assigns it to the right property. In the above example the view model has this property: @Required() @MaxLength(100) userName: string = ''; Now, the binding instruction looks like this: val<ViewModel>(e => e.userName, MaxLength, DisplayBindingHandler) The DisplayBindingHandler is smart enough to know that it's bound to an error message. It now reads the second parameter that is MaxLength . It binds now these two parts. First, it binds the error message to textContent . That's a static assignment. Second, it binds the display style to the isValid method of the view model. This method is set through the MaxLength decorator and knows how to determine the state 'maxlength'. The property is bound through the scope's Proxy dynamically and once the values changes, irrespectively the source of the change, it fires an event and the model binder holds a subscriber for this. Here, the value is taken and handed over to the isValid method. This method is bound to the handler, that sets the style accordingly. That setting is reversed, means that the value true makes the message invisible, while the value false makes the message visible ( isValid === false tells you an error occurred). If you use the DisplayBindingHandler or VisibilityBindingHandler directly, without validation but in conjunction with binding operations, than they will work straight, true makes an element visible, and false invisible. Handler Behavior # The DisplayBindingHandler sets display: none or display: block . The VisibilityBindingHandler sets visibility: hidden or visibility: visible . These are the most basic handlers and available out-of-the-box. If you need other values you must write a new handler with the desired behavior. This is, fortunately, extremely simple. Here is the source code for the handlers: export class DisplayBindingHandler implements IBindingHandler { react(binding: Binding): void { binding.el.style.display = binding.value ? 'block' : 'none'; } } export class VisibilityBindingHandler implements IBindingHandler { react(binding: Binding): void { binding.el.style.visibility = binding.value ? 'visible' : 'hidden'; } } The Binding instance, provided internally, delivers a boolean value. The element el is the element that has the n-bind={val<T>()} instruction. T is the model that drives the content using decorators. Additional Information # Objects are always set (not undefined), so you don't must test first. The property names are same as the decorators, but in lower case: @MaxLength : maxlength @MinLength : minlength @Pattern : pattern @Range : range @Required : required @EMail : email @Compare : compare","title":"Validation"},{"location":"md/docs/forms/validation/#validation","text":"Form validation is painful to programm from scratch. @nyaf/forms provides a n integrated but flexible validation system.","title":"Validation"},{"location":"md/docs/forms/validation/#view-model-decorators","text":"First, you need a viewmodel that has validation decorators. It's the same kind of model used for regular binding. Again, here is an example: export class UserViewModel { @Hidden() id: Number = 0; @Display('E-Mail', 'E-Mail address') @Required() @MaxLength(100) @Email() email: string = ''; @Display('Phone Number', \"The user's phone\") @Required('Please, the phone number is required') @MaxLength(20) phoneNumber: string = ''; @Display('User Name', 'The full name') @Required() @MaxLength(100) userName: string = ''; } Especially the validation decorators are in control of the validation ( Required , MaxLength , and so on). In binding instruction you tell the environment with what decorator a property has to be connected.","title":"View Model Decorators"},{"location":"md/docs/forms/validation/#state","text":"The validation state is available through state : this.model.state = { isValid: boolean, isPresent: boolean, errors: { [key: string]: string }, model: Model } It's supervised. After the component is rendered the property this.model.state helds the state of the model. After a binding happens the validators are being executed and the instance values change. You can retrieve the values in a method, or an event handler. To set UI elements interactively, immediately, you again use the n-bind attribute and the appropriate binding function like to and bind .","title":"State"},{"location":"md/docs/forms/validation/#bind-to-validators","text":"An error message is just regular output (the class values are taken from Bootstrap and they're not needed by the @nyaf/forms module): <form> <label n-bind=\"innerText: userName\" for=\"un\"/> <input n-bind=\"value: userName\" id=\"un\"> <div class=\"text text-danger\" n-bind={val<ViewModel>(e => e.userName, Required, DisplayBindingHandler)}> </div> </form> Validators can provide the error text, too. This is driven by decorators. The decorators fall back to a simple plain english error message in case you don't provide anything. You can, however, provide any kind of message in the decorator. In case you need i18n messages, just add the @Translate decorator as a parameter decorator to the message parameter. Distinguish between different validators like this: <form> <label n-bind=\"innerText: userName\" for=\"un\"/> <input n-bind=\"value: userName\" id=\"un\"> <span class=\"text text-danger\" n-bind={val<ViewModel>(e => e.userName, MaxLength, DisplayBindingHandler)}> </span> </form> The smart binder val is the key ingredient here. It takes three parameters: An expression to access the models actual value. A validator for which the binding is responsible (must also be aon the view models property). A display handler, that pulls the values and assigns it to the right property. In the above example the view model has this property: @Required() @MaxLength(100) userName: string = ''; Now, the binding instruction looks like this: val<ViewModel>(e => e.userName, MaxLength, DisplayBindingHandler) The DisplayBindingHandler is smart enough to know that it's bound to an error message. It now reads the second parameter that is MaxLength . It binds now these two parts. First, it binds the error message to textContent . That's a static assignment. Second, it binds the display style to the isValid method of the view model. This method is set through the MaxLength decorator and knows how to determine the state 'maxlength'. The property is bound through the scope's Proxy dynamically and once the values changes, irrespectively the source of the change, it fires an event and the model binder holds a subscriber for this. Here, the value is taken and handed over to the isValid method. This method is bound to the handler, that sets the style accordingly. That setting is reversed, means that the value true makes the message invisible, while the value false makes the message visible ( isValid === false tells you an error occurred). If you use the DisplayBindingHandler or VisibilityBindingHandler directly, without validation but in conjunction with binding operations, than they will work straight, true makes an element visible, and false invisible.","title":"Bind to Validators"},{"location":"md/docs/forms/validation/#handler-behavior","text":"The DisplayBindingHandler sets display: none or display: block . The VisibilityBindingHandler sets visibility: hidden or visibility: visible . These are the most basic handlers and available out-of-the-box. If you need other values you must write a new handler with the desired behavior. This is, fortunately, extremely simple. Here is the source code for the handlers: export class DisplayBindingHandler implements IBindingHandler { react(binding: Binding): void { binding.el.style.display = binding.value ? 'block' : 'none'; } } export class VisibilityBindingHandler implements IBindingHandler { react(binding: Binding): void { binding.el.style.visibility = binding.value ? 'visible' : 'hidden'; } } The Binding instance, provided internally, delivers a boolean value. The element el is the element that has the n-bind={val<T>()} instruction. T is the model that drives the content using decorators.","title":"Handler Behavior"},{"location":"md/docs/forms/validation/#additional-information","text":"Objects are always set (not undefined), so you don't must test first. The property names are same as the decorators, but in lower case: @MaxLength : maxlength @MinLength : minlength @Pattern : pattern @Range : range @Required : required @EMail : email @Compare : compare","title":"Additional Information"},{"location":"md/docs/forms/vm/","text":"View Models # First, you need view models. Then, you decorate the properties with validation and hint decorators. Why Using View Models? # View Models form an abstraction layer between code and pure user interface. They appear in many architectural pattern, such as Model-View-Control (MVC), Movel-View-ViewModel (MVVM), and similar constructs. A component library such as @nyaf is a different kind of pattern, but the basic need for a model is still valid. The ViewModel is essential when you want a separation of concerns between your DomainModel (DataModel) and the rest of your code. Decoupling and separation of concerns is one of the most crucial parts of modern software architectures. Models can contain code, have actions, and work as a distinct translator between the domain model and the view. It's not the same as the business logic, it's a layer between such a layer and the user interface (UI). A UI contains logic to control visible elements, such as tooltips, hints, and validation information. All this has no or only a weak relation to an underlying business logic. Mixing the both will create code that is hard to maintain, complex, and difficult to read. In software technology we often talk about so called software entropy. That's the process of code going to change over time into an even harder to manage form, with a lot of hacks, bells, and whistles nobody understands completely and that wil eventually start to fail. Levels of abstraction help to delay this process (it's an illusion that you can avoid it entirely). Viewmodels are hence an essential part of a good architecture. The flux architecture, delivered by the @nyaf/store module, seems to address a similar approach using store models and binding. However, this part is entirely devoted to the business logic. It's exactly that kind of abstraction we need to make great software not only by great design and an amazing stack of features, but by sheer quality, stability, with maintainable code, hard to break, and almost free of nasty bugs. Creating a View Model # A view model could look like this: export class UserViewModel { @Hidden() id: Number = 0; @Display('E-Mail', 'E-Mail address') @Required() @MaxLength(100) @Email() email: string = ''; @Display('Phone Number', 'The user\\'s phone') @Required('Please, the phone number is required') @MaxLength(20) phoneNumber: string = ''; @Display('User Name', 'The full name') @Required() @MaxLength(100) userName: string = ''; } The last (optional) parameter of the validation decorators is a custom error message. Validation Decorators # Validation decorators can be used together with the binding. After a binding action took place, usually after a change by the user, the state of the bound model updates and can be retrieved immediately. Elements bound to validation signals can use the state to show/hide elements or control sending data in code. The property names are the same as the respective decorators, just all lower case. Decorator Usage @MaxLength The maximum length of a text input. @MinLength The minimum length of a text input. @Pattern A regular expression that is used to test the text or number input. @Range A range (from-to) for either numerical values or dates. @Required Makes the field mandatory. @EMail Checks input against a (very good) regular expression to test for valid e-mail pattern. @Compare Compares with another field, usually for password comparison. @Custom Provide a static validation function as a callback for any custom validation. UI Decorators (property level) # UI decorators control the appearance of elements. Not all have an immediate effect, but it's very helpful while creating components to have meta data available. Decorator Usage @Display Determine the label's name and an (optional) tooltip. @DisplayGroup Groups components in <fieldset> elements. Can be ordered inside the form. @Hidden Makes an hidden field. @Sortable Makes a column sortable in table views. @Filterable Adds a filter in table views. @Placeholder A watermark that appears in empty form fields @ReadOnly Forces a particular render type. @TemplateHint What kind of field (text, number, date, ...) and additional styles or classes. The UI decorators do not enforce any specific behavior. In fact, they do almost nothing in an application without explicit support. The decorators create hidden properties you can retrieve when building the UI. That way you can control the behavior of the app by setting the decorators. It's some sort of abstraction between the view model and the UI. Mapping the Properties # The actual properties are of the form __propName__fieldName , that means, you have to add the decorated property name at the end to retrieve the property specific value. As an example, the displayText property, created by the decorator @Display , and placed on a property email , can be retrieved by this code: const text = this.model['__displayText__email']; However, the internal names may change and to avoid any issues a mapping with external names is available. The following table shows the properties the decorators create. Decorator function Properties Display text , order , desc DisplayGroup grouped , name , order , desc Hidden is Sortable is Filterable is Placeholder has , text ReadOnly is TemplateHint has , params , name Special Decorators # There is one more decorator that's not just defining the UI behavior but has some internal behavior. Decorator Usage @Translate For i18n of components This decorator can be placed on top of the view model, on class level, or on a specific property. export class ContactModel { constructor(init?: ContactModel) { if (init) { this.name = init.name; this.email = init.email; } } @Translate(json) @Display('Contact Name') @Required() name = ''; } The function expects a JSON file with translation instructions. The translation converts the text on the properties to another language: const json = { 'Contact Name': 'Kontaktname' }; This decorator is experimental and will change in the near future to reflect a more powerful approach. Providing the ViewModel # To make a ViewModel accessible you use the @ViewModel(T) decorator. More about this in the chapter Data Binding .","title":"View Models"},{"location":"md/docs/forms/vm/#view-models","text":"First, you need view models. Then, you decorate the properties with validation and hint decorators.","title":"View Models"},{"location":"md/docs/forms/vm/#why-using-view-models","text":"View Models form an abstraction layer between code and pure user interface. They appear in many architectural pattern, such as Model-View-Control (MVC), Movel-View-ViewModel (MVVM), and similar constructs. A component library such as @nyaf is a different kind of pattern, but the basic need for a model is still valid. The ViewModel is essential when you want a separation of concerns between your DomainModel (DataModel) and the rest of your code. Decoupling and separation of concerns is one of the most crucial parts of modern software architectures. Models can contain code, have actions, and work as a distinct translator between the domain model and the view. It's not the same as the business logic, it's a layer between such a layer and the user interface (UI). A UI contains logic to control visible elements, such as tooltips, hints, and validation information. All this has no or only a weak relation to an underlying business logic. Mixing the both will create code that is hard to maintain, complex, and difficult to read. In software technology we often talk about so called software entropy. That's the process of code going to change over time into an even harder to manage form, with a lot of hacks, bells, and whistles nobody understands completely and that wil eventually start to fail. Levels of abstraction help to delay this process (it's an illusion that you can avoid it entirely). Viewmodels are hence an essential part of a good architecture. The flux architecture, delivered by the @nyaf/store module, seems to address a similar approach using store models and binding. However, this part is entirely devoted to the business logic. It's exactly that kind of abstraction we need to make great software not only by great design and an amazing stack of features, but by sheer quality, stability, with maintainable code, hard to break, and almost free of nasty bugs.","title":"Why Using View Models?"},{"location":"md/docs/forms/vm/#creating-a-view-model","text":"A view model could look like this: export class UserViewModel { @Hidden() id: Number = 0; @Display('E-Mail', 'E-Mail address') @Required() @MaxLength(100) @Email() email: string = ''; @Display('Phone Number', 'The user\\'s phone') @Required('Please, the phone number is required') @MaxLength(20) phoneNumber: string = ''; @Display('User Name', 'The full name') @Required() @MaxLength(100) userName: string = ''; } The last (optional) parameter of the validation decorators is a custom error message.","title":"Creating a View Model"},{"location":"md/docs/forms/vm/#validation-decorators","text":"Validation decorators can be used together with the binding. After a binding action took place, usually after a change by the user, the state of the bound model updates and can be retrieved immediately. Elements bound to validation signals can use the state to show/hide elements or control sending data in code. The property names are the same as the respective decorators, just all lower case. Decorator Usage @MaxLength The maximum length of a text input. @MinLength The minimum length of a text input. @Pattern A regular expression that is used to test the text or number input. @Range A range (from-to) for either numerical values or dates. @Required Makes the field mandatory. @EMail Checks input against a (very good) regular expression to test for valid e-mail pattern. @Compare Compares with another field, usually for password comparison. @Custom Provide a static validation function as a callback for any custom validation.","title":"Validation Decorators"},{"location":"md/docs/forms/vm/#ui-decorators-property-level","text":"UI decorators control the appearance of elements. Not all have an immediate effect, but it's very helpful while creating components to have meta data available. Decorator Usage @Display Determine the label's name and an (optional) tooltip. @DisplayGroup Groups components in <fieldset> elements. Can be ordered inside the form. @Hidden Makes an hidden field. @Sortable Makes a column sortable in table views. @Filterable Adds a filter in table views. @Placeholder A watermark that appears in empty form fields @ReadOnly Forces a particular render type. @TemplateHint What kind of field (text, number, date, ...) and additional styles or classes. The UI decorators do not enforce any specific behavior. In fact, they do almost nothing in an application without explicit support. The decorators create hidden properties you can retrieve when building the UI. That way you can control the behavior of the app by setting the decorators. It's some sort of abstraction between the view model and the UI.","title":"UI Decorators (property level)"},{"location":"md/docs/forms/vm/#mapping-the-properties","text":"The actual properties are of the form __propName__fieldName , that means, you have to add the decorated property name at the end to retrieve the property specific value. As an example, the displayText property, created by the decorator @Display , and placed on a property email , can be retrieved by this code: const text = this.model['__displayText__email']; However, the internal names may change and to avoid any issues a mapping with external names is available. The following table shows the properties the decorators create. Decorator function Properties Display text , order , desc DisplayGroup grouped , name , order , desc Hidden is Sortable is Filterable is Placeholder has , text ReadOnly is TemplateHint has , params , name","title":"Mapping the Properties"},{"location":"md/docs/forms/vm/#special-decorators","text":"There is one more decorator that's not just defining the UI behavior but has some internal behavior. Decorator Usage @Translate For i18n of components This decorator can be placed on top of the view model, on class level, or on a specific property. export class ContactModel { constructor(init?: ContactModel) { if (init) { this.name = init.name; this.email = init.email; } } @Translate(json) @Display('Contact Name') @Required() name = ''; } The function expects a JSON file with translation instructions. The translation converts the text on the properties to another language: const json = { 'Contact Name': 'Kontaktname' }; This decorator is experimental and will change in the near future to reflect a more powerful approach.","title":"Special Decorators"},{"location":"md/docs/forms/vm/#providing-the-viewmodel","text":"To make a ViewModel accessible you use the @ViewModel(T) decorator. More about this in the chapter Data Binding .","title":"Providing the ViewModel"},{"location":"md/docs/internals/about/","text":"About # This project was created between 2019 and 2020 by Joerg Krause, Berlin, Germany. I like to introduce myself as an experienced expert especially for Web Technologies such as Angular, React, NodeJs, ASP.NET and common frameworks and systems such as .NET, SQL Server, IIS, and related subjects. I\u2019m a developer, consultant, trainer, and software architect. I work as a freelance senior consultant for enterprises and run a few thrilling projects on my own. To learn more, click in the section \u201acool stuff\u2018 in the right column. To find out more about me feel free to contact me or click \u201acurrent profiles\u2018 at the right. You can contact me in German and English language. I\u2019m available worldwide. A Short Introduction # I work as an software architect and technology consultant, especially around software development on the Microsoft Windows platform. He is focused in main topics such as Web Server development (including all web technologies, like HTML, CSS, JS/AJAX, as well as ASP.NET), SQL Server development (T-SQL, SSIS), and graphical environments (graphical Editors like IE and stuff based on it like Netrix, WPF, Silverlight). I\u2019m certified for several of these technologies and I\u2019m re-certifying regularly. I have published more than 60 books for Apress, Carl Hanser Verlag, Addison Wesley Germany, Markt + Technik and Symposion Publishing and in addition to more than 100 journal articles, notably for the German IT journals iX, DatabasePro, DOTNETpro, and \u201eASP.NET professional\u201c. I regularly speak at professional and scientific conferences (e.g. BASTA, Prio Conference, VSOne, DOTNET Conference, DotnetCologne, PHP Conference, DDC, and several INETA user group meetings). I run several thrilling projects, such as the component development of the Netrix Editor (Made by Guru Components), the software development company Augmented Software and the online publishing company Augmented Content. I\u2019m co-founder and stakeholder of all. If you want to get more information, want to join my network, seeking investment possibilities, or just want to be part of the party you\u2019re invited to contact me. Projects # I'M inventor and maintainer of @nyaf - an advanced Web Components framework. I'm the inventor and maintainer of SVOGV, an extension for Angular that provides dynamic forms, viewmodel decorators, and dynamic validation. Contact # Get me on the web (in German, see English About section).","title":"About"},{"location":"md/docs/internals/about/#about","text":"This project was created between 2019 and 2020 by Joerg Krause, Berlin, Germany. I like to introduce myself as an experienced expert especially for Web Technologies such as Angular, React, NodeJs, ASP.NET and common frameworks and systems such as .NET, SQL Server, IIS, and related subjects. I\u2019m a developer, consultant, trainer, and software architect. I work as a freelance senior consultant for enterprises and run a few thrilling projects on my own. To learn more, click in the section \u201acool stuff\u2018 in the right column. To find out more about me feel free to contact me or click \u201acurrent profiles\u2018 at the right. You can contact me in German and English language. I\u2019m available worldwide.","title":"About"},{"location":"md/docs/internals/about/#a-short-introduction","text":"I work as an software architect and technology consultant, especially around software development on the Microsoft Windows platform. He is focused in main topics such as Web Server development (including all web technologies, like HTML, CSS, JS/AJAX, as well as ASP.NET), SQL Server development (T-SQL, SSIS), and graphical environments (graphical Editors like IE and stuff based on it like Netrix, WPF, Silverlight). I\u2019m certified for several of these technologies and I\u2019m re-certifying regularly. I have published more than 60 books for Apress, Carl Hanser Verlag, Addison Wesley Germany, Markt + Technik and Symposion Publishing and in addition to more than 100 journal articles, notably for the German IT journals iX, DatabasePro, DOTNETpro, and \u201eASP.NET professional\u201c. I regularly speak at professional and scientific conferences (e.g. BASTA, Prio Conference, VSOne, DOTNET Conference, DotnetCologne, PHP Conference, DDC, and several INETA user group meetings). I run several thrilling projects, such as the component development of the Netrix Editor (Made by Guru Components), the software development company Augmented Software and the online publishing company Augmented Content. I\u2019m co-founder and stakeholder of all. If you want to get more information, want to join my network, seeking investment possibilities, or just want to be part of the party you\u2019re invited to contact me.","title":"A Short Introduction"},{"location":"md/docs/internals/about/#projects","text":"I'M inventor and maintainer of @nyaf - an advanced Web Components framework. I'm the inventor and maintainer of SVOGV, an extension for Angular that provides dynamic forms, viewmodel decorators, and dynamic validation.","title":"Projects"},{"location":"md/docs/internals/about/#contact","text":"Get me on the web (in German, see English About section).","title":"Contact"},{"location":"md/docs/internals/bit/","text":"Bit for @nyaf # This document explains how to write @nyaf components and publish to the Bit repository. This text is based on the similar strategy used by @nyaf . Overview # Bit lets you share and sync components between different projects and applications. In this tutorial, we'll share a @nyaf component between two projects. Prior Knowledge # This tutorial assumes that you are familiar with: Terminal and command line. Using node and npm or yarn. Web component development using @nyaf Git What Do You Need? # You need to verify that you have: Node 8.12+ (Node 12 LTS recommended) To run this tutorial, clone and setup the @nyaf tutorial project: https://github.com/joergkrause/bit-nyaf-tutorial git clone https://github.com/joergkrause/bit-nyaf-tutorial cd bit-**@nyaf**-tutorial npm i What Will You Learn? # In this tutorial you will learn how to: Setup Bit Share a @nyaf component from an existing project Preview the exported component on the Bit cloud Install the component in another project Modify the @nyaf component on the new project Get component updates Setup Bit # First things first, we need to setup Bit. Create a Free bit.dev Account Head over to bit.dev and create your free account. Enter a username and password or use your GitHub account to authenticate. Welcome to Bit! Make sure that you remember your username; you'll need it during this tutorial. Every time you see , replace it with your own username. Create a Component Collection When you are logged into bit.dev you can create a collection. A collection is a remotely-hosted set of components that are ready to be shared and used across your applications. Click the New button in the header and choose Collection. Name the new collection @nyaf -tutorial (or choose a different name, as long as you remember it). Decide if the collection is private or public. Public - Components in public collections are visible to everyone. Private - Components in private collections are available to invitees only. Install Bit CLI Install Bit CLI on your computer using npm: npm install bit-bin -g Copy Visit Install Bit for other installation methods. If you have Bit installed, verify the installation by running the command: bit --version Copy Login to Your Bit Account Authenticate Bit to your bit.dev account. From the command-line run: bit login Copy This will open your browser where you can log into your account. If you are already logged in, a success message will be displayed. You are now ready to start using Bit. As part of the login process, Bit sets up your local configuration. You can see your configuration by typing: bit config Copy In addition, Bit adds the npm registry used by Bit to your npmrc configuration. (by default located in $HOME/.npmrc according to your OS). Initialize Bit Workspace Switch to the @nyaf tutorial project directory and run the Bit initialization command using yarn: $ bit init --package-manager yarn successfully initialized a bit workspace. Copy We are going to use create- @nyaf -app, so it is recommended to use yarn. If you do not have Yarn installed, you can safely use npm. Now two other changes happen: A new file named .bitmap has been created in your root directory. This file tracks Bit components and only includes a comment and a line with your bit version. A new section, bit, has been added to your package.json file with the following defaults for your project: { \"bit\": { \"env\": {}, \"componentsDefaultDirectory\": \"components/{name}\", \"packageManager\": \"yarn\" } } Copy In an actual project, these changes should be committed to your version control tool system. Share a @nyaf Component Now, we will track the product-list component from the @nyaf tutorial project. The component will be tracked with the id product-list. Track a New Component To track the product list component, we will need to tell Bit about the component and the files that are related to it. As all the files are located under the product-list directory, the simplest way is to add all the files in the directory to your component. Bit will create a component named after the directory name. $ bit add src/components/product-list tracking component product-list: added src/components/product-list/index.js added src/components/product-list/product-list.css added src/components/product-list/products.js Copy When creating new components, you need to make sure that you have properly added all of the files required for the component. Bit can analyze the component for you and verify that all files are included. You can do that by checking the status of the component: $ bit status new components (use \"bit tag --all [version]\" to lock a version with all your changes) > product-list ... ok Copy We also added the products.js file that contains product data. In this demo application, it is acceptable as the file is used only by the product-list component. In other cases, however, if this file were used by multiple components you may want to consider creating the products.js file as a separate component that will become a dependency of the product-list and other components. Install @nyaf Compiler So far, we have provided Bit with the source file of the component. But in order to consume the files in other projects, the component needs to be built. Bit is storing the source code of the component, but the code should still remain in your version control system (VCS) such as your Git repository. Bit has a large collection of compilers that are open source and maintained by the Bit team. In addition, the community has created compilers that you can use by searching Bit collections. For building the @nyaf component, you'll need the @nyaf compiler. Install the compiler and run this command inside the @nyaf tutorial repository: $ bit import bit.envs/compilers/ @nyaf --compiler the following component environments were installed - bit.envs/ @nyaf @0.1.3 Copy The version may slightly vary when you run the tutorial The @nyaf compiler is now set as the default compiler for the Bit workspace inside this repository. You can check the package.json and verify that the compiler is installed by locating the following entry in the Bit section: { \"env\": { \"compiler\": \"bit.envs/compilers/ @nyaf @1.0.2\" }, } Copy Build the @nyaf Component Now that the compiler is installed, build the component. Building the component serves two purposes: Make the component directly consumable by other projects. Make sure that the component is all-inclusive and contains all the parts that are required in order to share it with others. Right now the component lives inside your project and may consume some dependencies from your project. Bit build is taking place in an isolated environment to make sure the process will also succeed on the cloud or in any other project. To build your component, run this command inside your @nyaf project: bit build Copy This results in the component name (product-list) followed by a list of file names. Those are the built files of the component. Export Component With the component properly built, it is now time to share it with the world. Components are versioned according to SemVer standards. To tag your component with a version, run the following command: $ bit tag --all 0.0.1 1 component(s) tagged (use \"bit export [collection]\" to push these components to a remote\") (use \"bit untag\" to unstage versions) new components (first version for components) > product-list@0.0.1 Copy This command tags all the components that are currently staged in Bit. In our case, it's only the product-list component. You can check the component status (bit status) and you'll find the following: $ bit status staged components (use \"bit export to push these components to a remote scope\") > product-list. versions: 0.0.1 ... ok Copy The important thing to notice here is that the component is considered staged. That means that it is now ready to be exported. To export the component to your bit.dev collection, we will use the export command and the full name of the collection, structured as . : $ bit export . @nyaf -tutorial exported 1 components to scope . @nyaf -tutorial Copy The component is now visible in your collection on bit.dev. You can access it in https://bit.dev/ / @nyaf -tutorial. You can also visit the component created for this demo on: https://bit.dev/learn-bit/ @nyaf -tutorial At this point, checking bit's status will no longer display the component as the component is now hosted on the remote collection: $ bit status nothing to tag or export Copy If you want to see all the components you have you can run: bit list Copy You will get a list of all components and their versions. Right now, the component code is in your local project (and should be committed to your source control), but it is also available for other projects. Preview the @nyaf Component The @nyaf component is also available on the bit.dev cloud. Go to https://bit.dev and log into your account (if you are not logged in yet): Select the collections navigator on the left panel and select collections. Click on your collection--you\u05f3ll see your product-list component. Click on the product-list component to see its playground. You can also access the page at the following url: https://bit.dev/ / @nyaf -tutorial/product-list The component playground provides you with a basic @nyaf app that already has your components. You can improve it a bit by adding a new file named styles.css with the following style: anchor { # flex-direction: column; } Copy Import styles.css into the index.js file in the playground: import './styles.css'; Copy Save the example In few seconds you will see the component rendered in the playground. You can view an example here. On the component's page, you can also see the different commands available for installing this component using yarn or npm. You can copy the yarn command; we are going to use it very soon. Install Component in Another Project Create a New @nyaf Application You are now going to create another @nyaf application and use the product-list component. The fastest way to do that is to use the @nyaf CLI to generate a new Application. Switch to a new directory. npx create- @nyaf -app my-new-app Copy In your terminal, switch to the my-new-app directory. Install the Component in Your Project Use your favorite package installer (yarn is preferred) to install the component. The component is stored in the Bit registry, so the full path to the component will be: @bit/ . . Run the install command using yarn: yarn add @bit/ . @nyaf -tutorial.product-list --save Copy If you want to use npm, run npm install once after the project is created so a package-lock.json will be created and npm will organize dependencies correctly. The component is now added to your package.json: \"@bit/ . @nyaf -tutorial.product-list\": \"0.0.1\" Copy Use In Your Application Now you can use the component in your code, just like any other import. Add it as a module to the top level app module and use it on the app page. We will make the same changes in the code as we did on the playground in the application: // App.js import ProductList from '@bit/ . @nyaf -tutorial.product-list'; function App() { return ( ); } Copy Update the css file: .App { flex-direction: column; margin: 20px; } Copy Last but not least, run your application using @nyaf CLI: yarn start Copy Voila! You can now see the components list inside the newly created application. Modify the Component Next, we are going to make a change to the component and export it back to the collection. We will add a View button to the product list. For simplicity, it will only show an alert saying the product has been viewed. Import the Component Up until now, the product-list component was only installed (in its built form) in our project. Now, we want to import the code into our project to make the changes. In order to import the component, initiate the my-new-app workspace as a Bit workspace: bit init Copy After the confirmation message that the workspace was initialized, run the following command: $ bit import . @nyaf -tutorial/product-list successfully imported one component - added . @nyaf -tutorial/product-list new versions: 0.0.1, currently used version 0.0.1 Copy Notifications on missing core dependencies are ok. You should already have those packages in your project. The command is also available on the component page. You get a message that the @ @nyaf /core and @ @nyaf /common are peer dependencies. This is ok, as your my-new-app project already contains them. Here is what happened: A new top-level components folder is created that includes the code of the component, with its compiled code and node_modules (in this case the node_modules are empty, as all of your node_modules are peer dependencies and are taken from the root project). The .bitmap file was modified to include the reference to the component The package.json file is modified to point to the files rather than the remote package. Your package.json now displays: { \"@bit/ . @nyaf -tutorial.product-list\": \"file:./components/product-list\" } Copy Start your application to make sure it still works. As you'll see, no changes are required: Bit takes care of everything. Update the Code Let's modify the product-list component. Change the components/product-list/index.js to include the following method: view() { window.alert('The product has been viewed!'); } Copy Change the getProduct function in components/product-list/index.js to include the new button: getProduct(product, index) { return ( {product.name} Description: {product.description} Share View </div> ) } Copy Change the css file components/product-list/product-list.css to include a margin on the .btn: margin: 4px; Copy Run the @nyaf application: yarn start Copy The app is not yet changed. That's because the Bit components are compiled by the bit compiler. In a separate terminal, run the bit build command to compile the changes. You should see that the compiler is installed: successfully installed the bit.envs/compilers/ @nyaf @0.1.3 compiler Copy That will be followed by a successful compilation of all of the files. Run the my-new-app again and you'll now see the changed component with the view button. In a real project, it is recommended to commit those changes to your GitHub repository. Export the Changes Next, export the changes done to the component back to bit.dev. bit status Copy The product-list component was modified: modified components (use \"bit tag --all [version]\" to lock a version with all your changes) (use \"bit diff\" to compare changes) > product-list ... ok Copy Tag and export the component as a new version. By default this is a SemVer patch version: $ bit tag product-list 1 component(s) tagged (use \"bit export [collection]\" to push these components to a remote\") (use \"bit untag\" to unstage versions) changed components (components that got a version bump) > . @nyaf -tutorial/product-list@0.0.2 Copy Export it back to the collection: $ bit export . @nyaf -tutorial exported 1 components to scope . @nyaf -tutorial Copy Head to the component page on bit.dev. Here you can see that the component has a new version. The changes are also visible on the component playground. You can see an example here Get Component Updates In this last stage, you'll import the changes to the original project. Switch back to @nyaf -tutorial. Import Changes Run bit import to see if any components were changed (similar to doing git pull to check git changes). We will see that the product-list component was changed and a new version exists: $ bit import successfully imported one component - updated . @nyaf -tutorial/product-list new versions: 0.0.2 Copy The component is downloaded but is not yet changed. Check the workspace status, you will get the following: $ bit status pending updates (use \"bit checkout [version] [component_id]\" to merge changes) (use \"bit diff [component_id] [new_version]\" to compare changes) (use \"bit log [component_id]\" to list all available versions) > <username>.**@nyaf**-tutorial/product-list current: 0.0.1 latest: 0.0.2 Copy Checkout Merge the changes done to the component to your project. The structure of the command is bit checkout . So you run: $ bit checkout 0.0.2 product-list successfully switched . @nyaf -tutorial/product-list to version 0.0.2 updated src/app/product-list/product-list.component.css updated src/app/product-list/product-list.component.html updated src/app/product-list/product-list.component.ts updated src/app/product-list/product-list.module.ts updated src/app/product-list/products.ts Copy Bit performs a git merge. The code from the updated component is now merged into your code. Run the application again to see it is working properly with the updated component: yarn start Copy That's it. A change was moved between the two projects. Your application is running with an updated component. Happy coding!","title":"Bit for @nyaf"},{"location":"md/docs/internals/bit/#bit-for-nyaf","text":"This document explains how to write @nyaf components and publish to the Bit repository. This text is based on the similar strategy used by @nyaf .","title":"Bit for @nyaf"},{"location":"md/docs/internals/bit/#overview","text":"Bit lets you share and sync components between different projects and applications. In this tutorial, we'll share a @nyaf component between two projects.","title":"Overview"},{"location":"md/docs/internals/bit/#prior-knowledge","text":"This tutorial assumes that you are familiar with: Terminal and command line. Using node and npm or yarn. Web component development using @nyaf Git","title":"Prior Knowledge"},{"location":"md/docs/internals/bit/#what-do-you-need","text":"You need to verify that you have: Node 8.12+ (Node 12 LTS recommended) To run this tutorial, clone and setup the @nyaf tutorial project: https://github.com/joergkrause/bit-nyaf-tutorial git clone https://github.com/joergkrause/bit-nyaf-tutorial cd bit-**@nyaf**-tutorial npm i","title":"What Do You Need?"},{"location":"md/docs/internals/bit/#what-will-you-learn","text":"In this tutorial you will learn how to: Setup Bit Share a @nyaf component from an existing project Preview the exported component on the Bit cloud Install the component in another project Modify the @nyaf component on the new project Get component updates","title":"What Will You Learn?"},{"location":"md/docs/internals/bit/#setup-bit","text":"First things first, we need to setup Bit. Create a Free bit.dev Account Head over to bit.dev and create your free account. Enter a username and password or use your GitHub account to authenticate. Welcome to Bit! Make sure that you remember your username; you'll need it during this tutorial. Every time you see , replace it with your own username. Create a Component Collection When you are logged into bit.dev you can create a collection. A collection is a remotely-hosted set of components that are ready to be shared and used across your applications. Click the New button in the header and choose Collection. Name the new collection @nyaf -tutorial (or choose a different name, as long as you remember it). Decide if the collection is private or public. Public - Components in public collections are visible to everyone. Private - Components in private collections are available to invitees only. Install Bit CLI Install Bit CLI on your computer using npm: npm install bit-bin -g Copy Visit Install Bit for other installation methods. If you have Bit installed, verify the installation by running the command: bit --version Copy Login to Your Bit Account Authenticate Bit to your bit.dev account. From the command-line run: bit login Copy This will open your browser where you can log into your account. If you are already logged in, a success message will be displayed. You are now ready to start using Bit. As part of the login process, Bit sets up your local configuration. You can see your configuration by typing: bit config Copy In addition, Bit adds the npm registry used by Bit to your npmrc configuration. (by default located in $HOME/.npmrc according to your OS). Initialize Bit Workspace Switch to the @nyaf tutorial project directory and run the Bit initialization command using yarn: $ bit init --package-manager yarn successfully initialized a bit workspace. Copy We are going to use create- @nyaf -app, so it is recommended to use yarn. If you do not have Yarn installed, you can safely use npm. Now two other changes happen: A new file named .bitmap has been created in your root directory. This file tracks Bit components and only includes a comment and a line with your bit version. A new section, bit, has been added to your package.json file with the following defaults for your project: { \"bit\": { \"env\": {}, \"componentsDefaultDirectory\": \"components/{name}\", \"packageManager\": \"yarn\" } } Copy In an actual project, these changes should be committed to your version control tool system. Share a @nyaf Component Now, we will track the product-list component from the @nyaf tutorial project. The component will be tracked with the id product-list. Track a New Component To track the product list component, we will need to tell Bit about the component and the files that are related to it. As all the files are located under the product-list directory, the simplest way is to add all the files in the directory to your component. Bit will create a component named after the directory name. $ bit add src/components/product-list tracking component product-list: added src/components/product-list/index.js added src/components/product-list/product-list.css added src/components/product-list/products.js Copy When creating new components, you need to make sure that you have properly added all of the files required for the component. Bit can analyze the component for you and verify that all files are included. You can do that by checking the status of the component: $ bit status new components (use \"bit tag --all [version]\" to lock a version with all your changes) > product-list ... ok Copy We also added the products.js file that contains product data. In this demo application, it is acceptable as the file is used only by the product-list component. In other cases, however, if this file were used by multiple components you may want to consider creating the products.js file as a separate component that will become a dependency of the product-list and other components. Install @nyaf Compiler So far, we have provided Bit with the source file of the component. But in order to consume the files in other projects, the component needs to be built. Bit is storing the source code of the component, but the code should still remain in your version control system (VCS) such as your Git repository. Bit has a large collection of compilers that are open source and maintained by the Bit team. In addition, the community has created compilers that you can use by searching Bit collections. For building the @nyaf component, you'll need the @nyaf compiler. Install the compiler and run this command inside the @nyaf tutorial repository: $ bit import bit.envs/compilers/ @nyaf --compiler the following component environments were installed - bit.envs/ @nyaf @0.1.3 Copy The version may slightly vary when you run the tutorial The @nyaf compiler is now set as the default compiler for the Bit workspace inside this repository. You can check the package.json and verify that the compiler is installed by locating the following entry in the Bit section: { \"env\": { \"compiler\": \"bit.envs/compilers/ @nyaf @1.0.2\" }, } Copy Build the @nyaf Component Now that the compiler is installed, build the component. Building the component serves two purposes: Make the component directly consumable by other projects. Make sure that the component is all-inclusive and contains all the parts that are required in order to share it with others. Right now the component lives inside your project and may consume some dependencies from your project. Bit build is taking place in an isolated environment to make sure the process will also succeed on the cloud or in any other project. To build your component, run this command inside your @nyaf project: bit build Copy This results in the component name (product-list) followed by a list of file names. Those are the built files of the component. Export Component With the component properly built, it is now time to share it with the world. Components are versioned according to SemVer standards. To tag your component with a version, run the following command: $ bit tag --all 0.0.1 1 component(s) tagged (use \"bit export [collection]\" to push these components to a remote\") (use \"bit untag\" to unstage versions) new components (first version for components) > product-list@0.0.1 Copy This command tags all the components that are currently staged in Bit. In our case, it's only the product-list component. You can check the component status (bit status) and you'll find the following: $ bit status staged components (use \"bit export to push these components to a remote scope\") > product-list. versions: 0.0.1 ... ok Copy The important thing to notice here is that the component is considered staged. That means that it is now ready to be exported. To export the component to your bit.dev collection, we will use the export command and the full name of the collection, structured as . : $ bit export . @nyaf -tutorial exported 1 components to scope . @nyaf -tutorial Copy The component is now visible in your collection on bit.dev. You can access it in https://bit.dev/ / @nyaf -tutorial. You can also visit the component created for this demo on: https://bit.dev/learn-bit/ @nyaf -tutorial At this point, checking bit's status will no longer display the component as the component is now hosted on the remote collection: $ bit status nothing to tag or export Copy If you want to see all the components you have you can run: bit list Copy You will get a list of all components and their versions. Right now, the component code is in your local project (and should be committed to your source control), but it is also available for other projects. Preview the @nyaf Component The @nyaf component is also available on the bit.dev cloud. Go to https://bit.dev and log into your account (if you are not logged in yet): Select the collections navigator on the left panel and select collections. Click on your collection--you\u05f3ll see your product-list component. Click on the product-list component to see its playground. You can also access the page at the following url: https://bit.dev/ / @nyaf -tutorial/product-list The component playground provides you with a basic @nyaf app that already has your components. You can improve it a bit by adding a new file named styles.css with the following style:","title":"Setup Bit"},{"location":"md/docs/internals/bit/#anchor","text":"flex-direction: column; } Copy Import styles.css into the index.js file in the playground: import './styles.css'; Copy Save the example In few seconds you will see the component rendered in the playground. You can view an example here. On the component's page, you can also see the different commands available for installing this component using yarn or npm. You can copy the yarn command; we are going to use it very soon. Install Component in Another Project Create a New @nyaf Application You are now going to create another @nyaf application and use the product-list component. The fastest way to do that is to use the @nyaf CLI to generate a new Application. Switch to a new directory. npx create- @nyaf -app my-new-app Copy In your terminal, switch to the my-new-app directory. Install the Component in Your Project Use your favorite package installer (yarn is preferred) to install the component. The component is stored in the Bit registry, so the full path to the component will be: @bit/ . . Run the install command using yarn: yarn add @bit/ . @nyaf -tutorial.product-list --save Copy If you want to use npm, run npm install once after the project is created so a package-lock.json will be created and npm will organize dependencies correctly. The component is now added to your package.json: \"@bit/ . @nyaf -tutorial.product-list\": \"0.0.1\" Copy Use In Your Application Now you can use the component in your code, just like any other import. Add it as a module to the top level app module and use it on the app page. We will make the same changes in the code as we did on the playground in the application: // App.js import ProductList from '@bit/ . @nyaf -tutorial.product-list'; function App() { return ( ); } Copy Update the css file: .App { flex-direction: column; margin: 20px; } Copy Last but not least, run your application using @nyaf CLI: yarn start Copy Voila! You can now see the components list inside the newly created application. Modify the Component Next, we are going to make a change to the component and export it back to the collection. We will add a View button to the product list. For simplicity, it will only show an alert saying the product has been viewed. Import the Component Up until now, the product-list component was only installed (in its built form) in our project. Now, we want to import the code into our project to make the changes. In order to import the component, initiate the my-new-app workspace as a Bit workspace: bit init Copy After the confirmation message that the workspace was initialized, run the following command: $ bit import . @nyaf -tutorial/product-list successfully imported one component - added . @nyaf -tutorial/product-list new versions: 0.0.1, currently used version 0.0.1 Copy Notifications on missing core dependencies are ok. You should already have those packages in your project. The command is also available on the component page. You get a message that the @ @nyaf /core and @ @nyaf /common are peer dependencies. This is ok, as your my-new-app project already contains them. Here is what happened: A new top-level components folder is created that includes the code of the component, with its compiled code and node_modules (in this case the node_modules are empty, as all of your node_modules are peer dependencies and are taken from the root project). The .bitmap file was modified to include the reference to the component The package.json file is modified to point to the files rather than the remote package. Your package.json now displays: { \"@bit/ . @nyaf -tutorial.product-list\": \"file:./components/product-list\" } Copy Start your application to make sure it still works. As you'll see, no changes are required: Bit takes care of everything. Update the Code Let's modify the product-list component. Change the components/product-list/index.js to include the following method: view() { window.alert('The product has been viewed!'); } Copy Change the getProduct function in components/product-list/index.js to include the new button: getProduct(product, index) { return (","title":"anchor {"},{"location":"md/docs/internals/lic/","text":"License # MIT License # Copyright (c) 2019 Joerg Krause, joerg@krause.net, www.joergkrause.de Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Licence"},{"location":"md/docs/internals/lic/#license","text":"","title":"License"},{"location":"md/docs/internals/lic/#mit-license","text":"Copyright (c) 2019 Joerg Krause, joerg@krause.net, www.joergkrause.de Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"md/docs/internals/praxis/","text":"Practical Work # This section shows common scenarios and how to deal with them in all day projects. Component Inheritance # Often you have multiple very similar components. As components are classes, we can use the comon inheritance technique. The base class of a group of components can be either .js or .ts or even .jsx or .tsx . The JSX variant is only needed i f you wish to write template code internally and use this. For components with pure code go with standard JavaScript/TypeScript classes. Base component classes derive from BaseComponent . You must call the constructor and you must add the render method. If the base component does not render anything (the final component does), then just return null in the implementation. In case you use TypeScript, using the keyword abstract leads to a clean code structure. The following example shows an abstract base component. export abstract class DemoBaseComponent extends BaseComponent { constructor() { super(); } abstract render(): Promise<string>; lifeCycle(lc: LifeCycle) { if (lc === LifeCycle.Render) { // Some action for all derived components } } } There is something remarkable here: The component lacks the @CustomElement decorator. It's not required because the class will never create a component directly. Also a registration is not necessary (and not possible), the inheritance is a pure language construct. The super call is required and the render method must be written, either abstract or with an implementation. You can also use any decorators on the base component, such as @InjectService on class level or @Select on property level. The class itself or the deriving class can also implement any of the helper interfaces, such as IModel or IStore .","title":"Praxis"},{"location":"md/docs/internals/praxis/#practical-work","text":"This section shows common scenarios and how to deal with them in all day projects.","title":"Practical Work"},{"location":"md/docs/internals/praxis/#component-inheritance","text":"Often you have multiple very similar components. As components are classes, we can use the comon inheritance technique. The base class of a group of components can be either .js or .ts or even .jsx or .tsx . The JSX variant is only needed i f you wish to write template code internally and use this. For components with pure code go with standard JavaScript/TypeScript classes. Base component classes derive from BaseComponent . You must call the constructor and you must add the render method. If the base component does not render anything (the final component does), then just return null in the implementation. In case you use TypeScript, using the keyword abstract leads to a clean code structure. The following example shows an abstract base component. export abstract class DemoBaseComponent extends BaseComponent { constructor() { super(); } abstract render(): Promise<string>; lifeCycle(lc: LifeCycle) { if (lc === LifeCycle.Render) { // Some action for all derived components } } } There is something remarkable here: The component lacks the @CustomElement decorator. It's not required because the class will never create a component directly. Also a registration is not necessary (and not possible), the inheritance is a pure language construct. The super call is required and the render method must be written, either abstract or with an implementation. You can also use any decorators on the base component, such as @InjectService on class level or @Select on property level. The class itself or the deriving class can also implement any of the helper interfaces, such as IModel or IStore .","title":"Component Inheritance"},{"location":"md/docs/internals/start/","text":"How it's being made # This chapter explains the inner workings and solutions used to create the framework. It's also an journey into ECMAScript beyond the usual usage scenario. The Base Component # This is by far the most complex part. It delivers the support for all the features @nyaf has to offer. Let's look into the inner parts step by step. Web Component # Ctor # Setup / Render # Life Cycle # Data Handling for Attributes # The Decorators # The Router # The router is simple yet powerful. It renders components in the outlet by adding the content to innerHTML . That invokes the component's life cycle. The Binder # The binder is part of @nyaf/forms and a complex piece of code that handles the smart rendering using Proxy objects. The usage of proxies has been criticized by many developers because of the complexity, difficult debugging and hard to follow behavior. They're, however, native functions of ECMAScript and fully supported by browsers. The ability to intercept property calls avoid building a n artificial layer on top of the components. The meain reason here is, that it safes a lot of space and makes the package much smaller.","title":"How it's being made"},{"location":"md/docs/internals/start/#how-its-being-made","text":"This chapter explains the inner workings and solutions used to create the framework. It's also an journey into ECMAScript beyond the usual usage scenario.","title":"How it's being made"},{"location":"md/docs/internals/start/#the-base-component","text":"This is by far the most complex part. It delivers the support for all the features @nyaf has to offer. Let's look into the inner parts step by step.","title":"The Base Component"},{"location":"md/docs/internals/start/#web-component","text":"","title":"Web Component"},{"location":"md/docs/internals/start/#ctor","text":"","title":"Ctor"},{"location":"md/docs/internals/start/#setup-render","text":"","title":"Setup / Render"},{"location":"md/docs/internals/start/#life-cycle","text":"","title":"Life Cycle"},{"location":"md/docs/internals/start/#data-handling-for-attributes","text":"","title":"Data Handling for Attributes"},{"location":"md/docs/internals/start/#the-decorators","text":"","title":"The Decorators"},{"location":"md/docs/internals/start/#the-router","text":"The router is simple yet powerful. It renders components in the outlet by adding the content to innerHTML . That invokes the component's life cycle.","title":"The Router"},{"location":"md/docs/internals/start/#the-binder","text":"The binder is part of @nyaf/forms and a complex piece of code that handles the smart rendering using Proxy objects. The usage of proxies has been criticized by many developers because of the complexity, difficult debugging and hard to follow behavior. They're, however, native functions of ECMAScript and fully supported by browsers. The ability to intercept property calls avoid building a n artificial layer on top of the components. The meain reason here is, that it safes a lot of space and makes the package much smaller.","title":"The Binder"},{"location":"md/docs/lib/attributes/","text":"State and Properties # There is no explicit difference between State and Property. Compared with React it's much more simpler. A state still exists and it supports smart rendering. State # To declare a state object use a generic like this: export class MainComponent extends BaseComponent<{ cnt: number}> { // ... omitted for brevity } The State generic is optional. If there is no state necessary just use any or an empty object such as {} . Now a property and a function are available: data (property): Returns the instance of the data object and contains all properties defined in the generic. setData(prop: string, val: any) (function): Sets a value and if the value differs re-renders the component. A simple counter shows how to use: export class CounterComponent extends BaseComponent<{ cnt: number }> { constructor() { super(); this.setData('cnt', 10); } clickMeAdd(v: number) { this.setData('cnt', this.data.cnt + 1); } clickMeSub(v: number) { this.setData('cnt', this.data.cnt - 1); } render() { return ( <> <div> <button type='button' n-on-click={e => this.clickMeAdd(e)}> Add 1 </button> <button type='button' n-on-click={e => this.clickMeSub(e)}> Sub 1 </button> </div> <pre style='border: 1px solid gray;'>{ this.data.cnt }</pre> </> ); } } However, changing this.data directly would be sufficient, too. The underlying object is a Proxy and can handle value changes automatically. The explicit function call is available to have a more dynamic approach through the property parameter. Properties # Property names in JavaScript are in camel case while HTML attribute names are in kebab case (dash-separated) to match HTML standards. For example, a JavaScript property named itemName maps to an HTML attribute named item-name . Don\u2019t start a property name with these characters: on (for example, onClick ) aria (for example, ariaDescribedby ) data (for example, dataProperty ) Don\u2019t use these reserved words for property names. slot part is To use properties, you must define those. Each property is automatically part of the state and once it changes, the component re-renders. @CustomElement('app-btn') @Properties<{ title: string }>({ title: 'Default' }) export class ButtonComponent extends BaseComponent<{ title: string, cnt: number }> { // ... omitted for brevity } The initializer with default's is not optional, you must provide an object that matches the generic. This is how you use such a component (part of the render method): const someTitle='Demo'; return (<app-btn title={someTitle} />); The @Properties decorator defines all properties, that are now monitored (observed) and hence the value is evaluated and rendered. If the value changes the component renders itself automatically. Accessing Properties # The access using the property with data is internally and externally available. That means, you can retrieve a component and set values like this: (this.querySelector('[data-demo-button]') as any) .data .text = 'Some demo data'; As with setData internally this will trigger the renderer to re-render the content with the new values, but in this case the trigger is outside the component. Data Types # Web Components have the restriction that an attribute can transport string values only. This would lead to \"[Object object]\" for other types. @nyaf overcomes this restriction with a smart attribute handling. That means the object is being recognized and stringified to JSON. Additionally, a custom attribute with the name \"__name__\" is written. Assume your value is written like shown below: <app-comp test={[{\"obj\": 1}, {\"obj\": 2}]}></app-comp> The rendered component would look like this: <app-comp test=\"[{\"obj\": 1}, {\"obj\": 2}]\" n-type-test=\"array\"></app-comp> Apparently the double double quotes work just fine. However, the content is now a string. If you do operations on this it will not resolve as the array it was before. Here the second attribute will trigger a different behavior. The hook for the data Proxy used internally is now applying a JSON.parse and returns the former object. Also, once set again, the incoming value is checked for being an object and stringified, then. The technique currently works for string (default Web Component behavior), number , boolean , array , and object . Be aware, that the automatic recognition of the data type is only possible if the value is provided as nativ type. This example will work: <app-comp cnt={100}></app-comp> In this example the value is recognized as string. It will remain a string event if you declare the observed attribute as number in the model type and @Properties decorator. Both settings are pure TypeScript features. they get stripped and will not be available at runtime. The render code will analyse the given object, that's only what's still available. <app-comp cnt='100'></app-comp> However, if you set the type by yourself, you can enforce the setting you wish. Be aware, that the type conversion must be possible by JavaScript to avoid runtime exceptions. See this example: <app-comp cnt='100' n-type-cnt='number'></app-comp> Here the JSX transformer will see the type string . But at runtime the additional attribute enforces a conversion back to number and keeps that type. The following example is not valid code. The type is recognized internally and the very same type attribute is created. So it would finally exist twice. While this will not necessarily result in an runtime error, the behavior is unpredictable and it can change in future versions. // this is illegal, the type is recognized internally <app-comp cnt={100} n-type-cnt='number'></app-comp> For extremely huge complex objects this technique might produce a performance penalty due to repeatedly used JSON.parse / JSON.stringify calls. Be also aware that this cannot work if the object has recursive structures, because the JSON class cannot deal with this. There is no additional error handling to keep the code small, it's just a try/catch block that reports the native error. Properties and Models # For a nice looking view some decorators applied to class properties control the appearance. export class Model { id: number = 0; name: string = ''; } @CustomElement('app-main') @Properties<Model>({ id: 0, name: '' }) export class MainComponent extends BaseComponent<Model> { // ... omitted for brevity } Within the component, this model now present. In the above definition this.data contains an actual model. The forms module contains a more sophisticated way to handle a view model with bi-directional data binding. the properties discussed here are for access from a parent component, while the form's module view models handle this internal binding. The settings of the decorator @Properties are the defaults, if no attributes are set. However, even if the existence of a default is not necessary, you must provide values here. This is due to the runtime behavior, where JavaScript requires a real type to create the instance properly. The generic in both places, the decorator and the base class, helps TypeScript to understand the model type and is mainly to support an excellent editor experience.","title":"Attributes"},{"location":"md/docs/lib/attributes/#state-and-properties","text":"There is no explicit difference between State and Property. Compared with React it's much more simpler. A state still exists and it supports smart rendering.","title":"State and Properties"},{"location":"md/docs/lib/attributes/#state","text":"To declare a state object use a generic like this: export class MainComponent extends BaseComponent<{ cnt: number}> { // ... omitted for brevity } The State generic is optional. If there is no state necessary just use any or an empty object such as {} . Now a property and a function are available: data (property): Returns the instance of the data object and contains all properties defined in the generic. setData(prop: string, val: any) (function): Sets a value and if the value differs re-renders the component. A simple counter shows how to use: export class CounterComponent extends BaseComponent<{ cnt: number }> { constructor() { super(); this.setData('cnt', 10); } clickMeAdd(v: number) { this.setData('cnt', this.data.cnt + 1); } clickMeSub(v: number) { this.setData('cnt', this.data.cnt - 1); } render() { return ( <> <div> <button type='button' n-on-click={e => this.clickMeAdd(e)}> Add 1 </button> <button type='button' n-on-click={e => this.clickMeSub(e)}> Sub 1 </button> </div> <pre style='border: 1px solid gray;'>{ this.data.cnt }</pre> </> ); } } However, changing this.data directly would be sufficient, too. The underlying object is a Proxy and can handle value changes automatically. The explicit function call is available to have a more dynamic approach through the property parameter.","title":"State"},{"location":"md/docs/lib/attributes/#properties","text":"Property names in JavaScript are in camel case while HTML attribute names are in kebab case (dash-separated) to match HTML standards. For example, a JavaScript property named itemName maps to an HTML attribute named item-name . Don\u2019t start a property name with these characters: on (for example, onClick ) aria (for example, ariaDescribedby ) data (for example, dataProperty ) Don\u2019t use these reserved words for property names. slot part is To use properties, you must define those. Each property is automatically part of the state and once it changes, the component re-renders. @CustomElement('app-btn') @Properties<{ title: string }>({ title: 'Default' }) export class ButtonComponent extends BaseComponent<{ title: string, cnt: number }> { // ... omitted for brevity } The initializer with default's is not optional, you must provide an object that matches the generic. This is how you use such a component (part of the render method): const someTitle='Demo'; return (<app-btn title={someTitle} />); The @Properties decorator defines all properties, that are now monitored (observed) and hence the value is evaluated and rendered. If the value changes the component renders itself automatically.","title":"Properties"},{"location":"md/docs/lib/attributes/#accessing-properties","text":"The access using the property with data is internally and externally available. That means, you can retrieve a component and set values like this: (this.querySelector('[data-demo-button]') as any) .data .text = 'Some demo data'; As with setData internally this will trigger the renderer to re-render the content with the new values, but in this case the trigger is outside the component.","title":"Accessing Properties"},{"location":"md/docs/lib/attributes/#data-types","text":"Web Components have the restriction that an attribute can transport string values only. This would lead to \"[Object object]\" for other types. @nyaf overcomes this restriction with a smart attribute handling. That means the object is being recognized and stringified to JSON. Additionally, a custom attribute with the name \"__name__\" is written. Assume your value is written like shown below: <app-comp test={[{\"obj\": 1}, {\"obj\": 2}]}></app-comp> The rendered component would look like this: <app-comp test=\"[{\"obj\": 1}, {\"obj\": 2}]\" n-type-test=\"array\"></app-comp> Apparently the double double quotes work just fine. However, the content is now a string. If you do operations on this it will not resolve as the array it was before. Here the second attribute will trigger a different behavior. The hook for the data Proxy used internally is now applying a JSON.parse and returns the former object. Also, once set again, the incoming value is checked for being an object and stringified, then. The technique currently works for string (default Web Component behavior), number , boolean , array , and object . Be aware, that the automatic recognition of the data type is only possible if the value is provided as nativ type. This example will work: <app-comp cnt={100}></app-comp> In this example the value is recognized as string. It will remain a string event if you declare the observed attribute as number in the model type and @Properties decorator. Both settings are pure TypeScript features. they get stripped and will not be available at runtime. The render code will analyse the given object, that's only what's still available. <app-comp cnt='100'></app-comp> However, if you set the type by yourself, you can enforce the setting you wish. Be aware, that the type conversion must be possible by JavaScript to avoid runtime exceptions. See this example: <app-comp cnt='100' n-type-cnt='number'></app-comp> Here the JSX transformer will see the type string . But at runtime the additional attribute enforces a conversion back to number and keeps that type. The following example is not valid code. The type is recognized internally and the very same type attribute is created. So it would finally exist twice. While this will not necessarily result in an runtime error, the behavior is unpredictable and it can change in future versions. // this is illegal, the type is recognized internally <app-comp cnt={100} n-type-cnt='number'></app-comp> For extremely huge complex objects this technique might produce a performance penalty due to repeatedly used JSON.parse / JSON.stringify calls. Be also aware that this cannot work if the object has recursive structures, because the JSON class cannot deal with this. There is no additional error handling to keep the code small, it's just a try/catch block that reports the native error.","title":"Data Types"},{"location":"md/docs/lib/attributes/#properties-and-models","text":"For a nice looking view some decorators applied to class properties control the appearance. export class Model { id: number = 0; name: string = ''; } @CustomElement('app-main') @Properties<Model>({ id: 0, name: '' }) export class MainComponent extends BaseComponent<Model> { // ... omitted for brevity } Within the component, this model now present. In the above definition this.data contains an actual model. The forms module contains a more sophisticated way to handle a view model with bi-directional data binding. the properties discussed here are for access from a parent component, while the form's module view models handle this internal binding. The settings of the decorator @Properties are the defaults, if no attributes are set. However, even if the existence of a default is not necessary, you must provide values here. This is due to the runtime behavior, where JavaScript requires a real type to create the instance properly. The generic in both places, the decorator and the base class, helps TypeScript to understand the model type and is mainly to support an excellent editor experience.","title":"Properties and Models"},{"location":"md/docs/lib/directives/","text":"Directives # Directives are extensions to host components that are bound to attributes. Think of it like smart handling for data, events, or actions. Make a Directive # To make a directive you use the @Directive decorator and the base class BaseDirective . The directive helps registering the class. The base class supports the editor and type safety. A simple example shows how to make any element draggeable. @Directive('[directive=\"drag\"]') export class DragDirective extends BaseDirective { constructor(public host: HTMLElement) { super(host); this.host.draggable = true; } setup() { this.host.addEventListener('dragstart', (e: DragEvent) => { e.dataTransfer.setData('text', 'from button'); }); this.host.addEventListener('dragover', (e: DragEvent) => { e.preventDefault(); }); } } Directives are activated by any kind of selector querySelectorAll can process. In the example we use the [directive=\"drag\"] selector, which is an attribute with a value. To apply this directive, two steps are required. As always, you must register your directive first You apply the selector to any element (standard HTML, Web Components, or own stuff - it works everywhere) Registration # The registration is part of the GlobalProvider 's bootstrap process: // example import import { DropTargetDirective, DragDirective } from './directives/index'; GlobalProvider.bootstrap({ // other parts omitted for brevity directives: [DropTargetDirective, DragDirective], // other parts omitted for brevity }); Activation # The directive applies ones a component renders. That means, the directive must be part of an @nyaf web component. But the actual assignment can be placed on any HTML element. If you have just one global component and pure HTML in it, then the directive will still work. To activate the directive just add the selector to an element: <button type='button' directive='drag'> Drag me around </button> The element becomes now a host element for the directive. One directive can be applied to many elements. They are isolated instances. For each occurrence of the selector a new instance of the directive class is created. Working with Host Elements # To get access to the host the directive shall modify a property host that is provided by the base class. It's available immediately after the super call of the constructor and injected as a constructor parameter. That's mandatory. constructor(public host: HTMLElement) { super(host); // here you can safely access the host element } After the constructor call the infrastructure calls a method setup . It has no parameters and is not awaitable. It's a good point to add event listeners or add further modifications to the element as shown in the example above. The host element is aware of a shadow DOM, so it might be the host's element object or a shadowed element. This depends on the usage of the @ShadowDOM directive. There is nothing special here, you can use it directly. The type cast is HTMLElement . That means in TypeScript the properties specific to shadow DOM are not available in the API. In JavaScript they are still present, though, that means you could enforce a cast like this.host as unknown as ShadowRoot . Usually, that's a very rare situation anyway. The idea behind this behavior is that we want to make the shadow DOM as transparent as possible, without forcing the developer to think about it.","title":"Directives"},{"location":"md/docs/lib/directives/#directives","text":"Directives are extensions to host components that are bound to attributes. Think of it like smart handling for data, events, or actions.","title":"Directives"},{"location":"md/docs/lib/directives/#make-a-directive","text":"To make a directive you use the @Directive decorator and the base class BaseDirective . The directive helps registering the class. The base class supports the editor and type safety. A simple example shows how to make any element draggeable. @Directive('[directive=\"drag\"]') export class DragDirective extends BaseDirective { constructor(public host: HTMLElement) { super(host); this.host.draggable = true; } setup() { this.host.addEventListener('dragstart', (e: DragEvent) => { e.dataTransfer.setData('text', 'from button'); }); this.host.addEventListener('dragover', (e: DragEvent) => { e.preventDefault(); }); } } Directives are activated by any kind of selector querySelectorAll can process. In the example we use the [directive=\"drag\"] selector, which is an attribute with a value. To apply this directive, two steps are required. As always, you must register your directive first You apply the selector to any element (standard HTML, Web Components, or own stuff - it works everywhere)","title":"Make a Directive"},{"location":"md/docs/lib/directives/#registration","text":"The registration is part of the GlobalProvider 's bootstrap process: // example import import { DropTargetDirective, DragDirective } from './directives/index'; GlobalProvider.bootstrap({ // other parts omitted for brevity directives: [DropTargetDirective, DragDirective], // other parts omitted for brevity });","title":"Registration"},{"location":"md/docs/lib/directives/#activation","text":"The directive applies ones a component renders. That means, the directive must be part of an @nyaf web component. But the actual assignment can be placed on any HTML element. If you have just one global component and pure HTML in it, then the directive will still work. To activate the directive just add the selector to an element: <button type='button' directive='drag'> Drag me around </button> The element becomes now a host element for the directive. One directive can be applied to many elements. They are isolated instances. For each occurrence of the selector a new instance of the directive class is created.","title":"Activation"},{"location":"md/docs/lib/directives/#working-with-host-elements","text":"To get access to the host the directive shall modify a property host that is provided by the base class. It's available immediately after the super call of the constructor and injected as a constructor parameter. That's mandatory. constructor(public host: HTMLElement) { super(host); // here you can safely access the host element } After the constructor call the infrastructure calls a method setup . It has no parameters and is not awaitable. It's a good point to add event listeners or add further modifications to the element as shown in the example above. The host element is aware of a shadow DOM, so it might be the host's element object or a shadowed element. This depends on the usage of the @ShadowDOM directive. There is nothing special here, you can use it directly. The type cast is HTMLElement . That means in TypeScript the properties specific to shadow DOM are not available in the API. In JavaScript they are still present, though, that means you could enforce a cast like this.host as unknown as ShadowRoot . Usually, that's a very rare situation anyway. The idea behind this behavior is that we want to make the shadow DOM as transparent as possible, without forcing the developer to think about it.","title":"Working with Host Elements"},{"location":"md/docs/lib/events/","text":"Events # Events are defined by a special instruction. They are attached to document object, regardless the usage. n-on-event # Events are easy to add directly using them like n-on-click . All JavaScript events are supported. Just replace 'click' in the example with any other JavaScript event. <button n-on-click={() => this.clickMe()}>OK</button> There is no bind necessary, events are bound to components anyway. You can get the (original HTML 5 API) event using a parameter, like e in the example below: <button n-on-click={(e) => this.clickMe(e)}>OK</button> Because the method can be bound with or without the event object as a parameter, the method can have an optional parameter like this: clickMe(e?: Event) { } The Event type conforms to HTML 5 DOM. Replace the type according the attached event ( MouseEvent etc., see here for details). Syntax Enhancements # This section shows some variations of the event syntax that might better suit your needs. Short Form # If you don't need access to the parameters of the event (example: a click, which just happens), a short form is possible: <button type=\"button\" n-on-click={this.clickMe}> Additional Parameters # You can add constant values like this: <button type=\"button\" n-on-click={(e) => this.clickMe(e, 'PROP')}> Warning! Regardless the type, the received value will be a string type at runtime. <button type=\"button\" n-on-click={(e) => this.clickMe(e, 100)}> This works, but the function will receive \"100\". <button type=\"button\" n-on-click={(e) => this.clickMe(e, 1 + 2)}> This works, too, but the function will receive \"1 + 2\". The expression is not being executed! So, this is somehow limited in the current version. You can add multiple parameters, though. <button type=\"button\" n-on-click={(e) => this.clickMe(e, 1, 2)}> clickMe(e: Event, a: string, b: string) { const r = +a + +b; } Usually, it doesn't make sense to have calculation on constant values. So in reality this isn't a serious limitation. Async # You can combine any event with the attribute n-async to make the call to the event's handler function async. This attribute does not take any parameters. The handler method can be decorated with async . <button n-on-click={this.clickMe} n-async>OK</button> async clickMe(e?: Event) { // handle asynchronously } Custom Events # Sometimes the JavaScript events are not flexible enough. So you can define your own ones. That's done by three simple steps: Add a decorator @Events to declare the events (it's an array to declare multiple in one step). This is mandatory. Create a CustomEventInit object and dispatch it (this is native Web Component behavior ) Use the n-on-<myCustomEventName> attribute to attach the event in the parent component. Imagine a button component like this: @CustomElement('app-button') @Events(['showAlert']) export class ButtonComponent extends BaseComponent { constructor() { super(); } clickMe() { const checkEvent: CustomEventInit = { bubbles: true, cancelable: false, }; super.dispatch('showAlert', checkEvent); } render() { return ( <button type=\"button\" n-on-click={this.clickMe}> Demo </button> ); } } The custom event in this example is called showAlert . It's invoked by a click. The element's host component has code like this: <app-button n-on-showAlert={(e) => this.someHandler(e)} /> The argument e contains an CustomEvent object. It can carry any number of custom data. The click -invoker is just an example, any action can call a custom event, even a web socket callback, a timer, or an HTTP request result. Both CustomEvent and CustomEventInit have a field detail that can carry any object or scalar and is the proposed way to transport custom data with the event. The event handler could look like this: private someHandler(e: CustomEvent) { const data = e.detail; // Your code that handles the event } Custom events can be async, too. Just add n-async to the element that fires the event and add the async modifier to the handler.","title":"Events"},{"location":"md/docs/lib/events/#events","text":"Events are defined by a special instruction. They are attached to document object, regardless the usage.","title":"Events"},{"location":"md/docs/lib/events/#n-on-event","text":"Events are easy to add directly using them like n-on-click . All JavaScript events are supported. Just replace 'click' in the example with any other JavaScript event. <button n-on-click={() => this.clickMe()}>OK</button> There is no bind necessary, events are bound to components anyway. You can get the (original HTML 5 API) event using a parameter, like e in the example below: <button n-on-click={(e) => this.clickMe(e)}>OK</button> Because the method can be bound with or without the event object as a parameter, the method can have an optional parameter like this: clickMe(e?: Event) { } The Event type conforms to HTML 5 DOM. Replace the type according the attached event ( MouseEvent etc., see here for details).","title":"n-on-event"},{"location":"md/docs/lib/events/#syntax-enhancements","text":"This section shows some variations of the event syntax that might better suit your needs.","title":"Syntax Enhancements"},{"location":"md/docs/lib/events/#short-form","text":"If you don't need access to the parameters of the event (example: a click, which just happens), a short form is possible: <button type=\"button\" n-on-click={this.clickMe}>","title":"Short Form"},{"location":"md/docs/lib/events/#additional-parameters","text":"You can add constant values like this: <button type=\"button\" n-on-click={(e) => this.clickMe(e, 'PROP')}> Warning! Regardless the type, the received value will be a string type at runtime. <button type=\"button\" n-on-click={(e) => this.clickMe(e, 100)}> This works, but the function will receive \"100\". <button type=\"button\" n-on-click={(e) => this.clickMe(e, 1 + 2)}> This works, too, but the function will receive \"1 + 2\". The expression is not being executed! So, this is somehow limited in the current version. You can add multiple parameters, though. <button type=\"button\" n-on-click={(e) => this.clickMe(e, 1, 2)}> clickMe(e: Event, a: string, b: string) { const r = +a + +b; } Usually, it doesn't make sense to have calculation on constant values. So in reality this isn't a serious limitation.","title":"Additional Parameters"},{"location":"md/docs/lib/events/#async","text":"You can combine any event with the attribute n-async to make the call to the event's handler function async. This attribute does not take any parameters. The handler method can be decorated with async . <button n-on-click={this.clickMe} n-async>OK</button> async clickMe(e?: Event) { // handle asynchronously }","title":"Async"},{"location":"md/docs/lib/events/#custom-events","text":"Sometimes the JavaScript events are not flexible enough. So you can define your own ones. That's done by three simple steps: Add a decorator @Events to declare the events (it's an array to declare multiple in one step). This is mandatory. Create a CustomEventInit object and dispatch it (this is native Web Component behavior ) Use the n-on-<myCustomEventName> attribute to attach the event in the parent component. Imagine a button component like this: @CustomElement('app-button') @Events(['showAlert']) export class ButtonComponent extends BaseComponent { constructor() { super(); } clickMe() { const checkEvent: CustomEventInit = { bubbles: true, cancelable: false, }; super.dispatch('showAlert', checkEvent); } render() { return ( <button type=\"button\" n-on-click={this.clickMe}> Demo </button> ); } } The custom event in this example is called showAlert . It's invoked by a click. The element's host component has code like this: <app-button n-on-showAlert={(e) => this.someHandler(e)} /> The argument e contains an CustomEvent object. It can carry any number of custom data. The click -invoker is just an example, any action can call a custom event, even a web socket callback, a timer, or an HTTP request result. Both CustomEvent and CustomEventInit have a field detail that can carry any object or scalar and is the proposed way to transport custom data with the event. The event handler could look like this: private someHandler(e: CustomEvent) { const data = e.detail; // Your code that handles the event } Custom events can be async, too. Just add n-async to the element that fires the event and add the async modifier to the handler.","title":"Custom Events"},{"location":"md/docs/lib/jsx/","text":"JSX / TSX # Fundamentally, JSX just provides syntactic sugar for the code line JSX.createElement(component, props, ...children) function. The transformation and conversion to JavaScript is made by the TypeScript transpiler. In case you use pure JavaScript, the best tool to compile JSX is Babel. Be aware, that while the main framework with native JSX support is React, @nyaf has absolutely no relation to React, and the behavior of the code is different. Introduction # The next examples assume that some code surrounds the snippets or is just the return value of the render() method. See some TSX code used in a component: <my-button color=\"blue\" shadowSize={2}> Click Me </my-button> This piece of code compiles into the following function call: JSX.createElement( 'my-button', {color: 'blue', shadowSize: 2}, 'Click Me' ) JSX Scope # Since JSX compiles into calls to JSX.createElement , the JSX class must also always be in scope from your TSX code. For example, both of the imports are necessary in this code, even though React and CustomButton are not directly referenced from JavaScript: import JSX from '@nyaf/lib'; // code omitted for brevity render() { // return JSX.createElement('custom-button', {color: 'red'}, null); return (<custom-button color=\"red\" />); } Note that this is a default export, so no curly braces here! If you don\u2019t use a JavaScript bundler and load @nyaf from a <script> tag, it is already in scope as a global object named JSX . The elements used in the JSX parts are registered globally and there is no additional import required. That's a fundamentally different behavior in comparison to React. In React the first argument is a type and the elements will render itself based on the given type. In @nyaf the first argument is a string, and the constructed element is pushed to the browser as string through innerHTML , and the browser renders the content directly using native code. Examples # You can also use the self-closing form of the tag if there are no children. <div class=\"sidebar\" /> This piece of code compiles into this JavaScript: JSX.createElement('div', {'class': 'sidebar'}) If you want to test out how some specific JSX is converted into JavaScript, you can try out the online Babel compiler . Be aware that in case of any JSX oriented tools not explicitly configured for @nyaf may create the code with the namespace React . In fact, the online Babel transpiler creates something like this: React.createElement(\"div\", { class: \"sidebar\" }); That's pretty much the same, so it will work as learning tool, but keep the changed names in mind. Specifying the Element Type # The first part of a TSX tag determines the type of the element. It's the name of a registered Web Component. Web Components Must be in Kebab Style # When an element type starts with a lowercase letter, it refers to a built-in component like <div> or <span> and results in a string 'div' or 'span' passed to JSX.createElement . Types that have a dashed name like <my-foo /> compile to JSX.createElement('my-foo') and correspond to a component defined globally through GlobalProvider . We recommend naming components always with kebab style. Properties in TSX # There are several different ways to specify properties in TSX. JavaScript Expressions as Properties # You can pass any JavaScript expression as a property, by surrounding it with curly braces ( {} ). For example, see this TSX: <my-component foo={1 + 2 + 3 + 4} /> For 'my-component', the value of props.foo will be 10 because the expression 1 + 2 + 3 + 4 gets evaluated. if statements and for loops are not expressions in JavaScript, so they can\u2019t be used in TSX directly. Instead, you can put these in the surrounding code. For example see this snippet from a component class: NumberDescriber(props): string { let description; if (props.number % 2 == 0) { description = <strong>even</strong>; } else { description = <i>odd</i>; } return (<div>{props.number} is an {description} number</div>); } This method uses TSX expressions directly in the code. There is no relation with the render method, the expressions can appear everywhere and they will return always string value. You can learn more about conditional rendering and loops in the corresponding sections. String Literals # You can pass a string literal as a property. These two TSX expressions are equivalent: <my-component message=\"hello world\" /> <my-component message={'hello world'} /> When you pass a string literal, its value is HTML-unescaped. So these two TSX expressions are equivalent: <my-component message=\"&lt;3\" /> <my-component message={'<3'} /> This behavior is usually not relevant. It\u2019s only mentioned here for completeness. Properties Default to True # If you pass no value for a property, it defaults to true. These two TSX expressions are equivalent: <my-textbox autocomplete /> <my-textbox autocomplete={true} /> In general, we don\u2019t recommend not passing a value for a property, because it can be confused with the ES2015 object shorthand {foo} which is short for {foo: foo} rather than {foo: true} . This behavior is just there so that it matches the behavior of HTML. Spread Attributes # If you already have properties as an object, and you want to pass it in JSX, you can use ... as a \u201cspread\u201d operator to pass the whole object. These two methods are equivalent: getApp1(): string { return <app-greeting firstName=\"Joerg\" lastName=\"Krause\" />; } getApp2(): string { const props = {firstName: 'Joerg', lastName: 'Krause'}; return <app-greeting {...props} />; } You can also pick specific properties that your component will consume while passing all other props using the spread operator. const Button = props => { const { kind, ...other } = props; const cls = kind === \"primary\" ? \"PrimaryButton\" : \"SecondaryButton\"; return <button class={cls} {...other} />; }; const getApp = () => { return ( <div> <Button kind=\"primary\" onClick={() => console.log(\"clicked!\")}> Hello World! </Button> </div> ); }; In the example above, the kind property is safely consumed and is not passed on to the <button> element in the DOM. All other properties are passed via the ...other object making this component really flexible. You can see that it passes an onClick and children properties. Spread attributes can be useful but they also make it easy to pass unnecessary properties to components that don\u2019t care about them or to pass invalid HTML attributes to the DOM. It's recommended using this syntax sparingly. Children in TSX # In TSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special property this.children . There are several different ways to pass children. String Literals # You can put a string between the opening and closing tags and this.children will just be that string. This is useful for many of the built-in HTML elements. For example: <my-component>Hello world!</my-component> This is valid TSX, and this.children in MyComponent will simply be the string \"Hello world!\". HTML is unescaped, so you can generally write TSX just like you would write HTML in this way: <div>This is valid HTML &amp; TSX at the same time.</div> TSX removes whitespace at the beginning and ending of a line. It also removes blank lines. New lines adjacent to tags are removed; new lines that occur in the middle of string literals are condensed into a single space. So these all render to the same thing: <div>Hello World</div> <div> Hello World </div> <div> Hello World </div> <div> Hello World </div> TSX Children # You can provide more TSX elements as the children. This is useful for displaying nested components: <my-container> <my-first-component /> <my-second-component /> </my-container> You can mix together different types of children, so you can use string literals together with TSX children. This is another way in which TSX is like HTML, so that this is both valid JSX and valid HTML: <div> Here is a list: <ul> <li>Item 1</li> <li>Item 2</li> </ul> </div> Expressions as Children # You can pass any JavaScript expression as children, by enclosing it within {} . For example, these expressions are equivalent: <my-component>foo</my-component> <my-component>{'foo'}</my-component> This is often useful for rendering a list of JSX expressions of arbitrary length. For example, this renders an HTML list: Item(data: { message: string }): string { return <li>{data.message}</li>; } todoList(): string { const todos = ['create tests', 'fix bugs', 'attend scrum']; return ( <ul> {todos.map((msg) => <my-item message={message} />)} </ul> ); } JavaScript expressions can be mixed with other types of children. This is often useful in lieu of string templates: hello(data: { addressee: string }): string { return <div>Hello {data.addressee}!</div>; } Booleans, Null, and Undefined # The values false , null , undefined , and true are valid children. They simply don\u2019t render. These TSX expressions will all render to the same thing: <div /> <div></div> <div>{false}</div> <div>{null}</div> <div>{undefined}</div> <div>{true}</div> This can be useful to conditionally render elements. This TSX renders the component only if showHeader is true : <div> {showHeader && <app-header />} <app-content /> </div> One caveat is that some \u201cfalsy\u201d values, such as the 0 number, are still rendered by React. For example, this code will not behave as you might expect because 0 will be printed when data.messages is an empty array: <div> {this.data.messages.length && <message-list messages={this.data.messages} /> } </div> To fix this, make sure that the expression before && is always boolean : <div> {this.data.messages.length > 0 && <message-list messages={this.data.messages} /> } </div> Conversely, if you want a value like false , true , null , or undefined to appear in the output, you have to convert it to a string first: <div> The JavaScript variable is {String(myVariable)}. </div>","title":"JSX / TSX"},{"location":"md/docs/lib/jsx/#jsx-tsx","text":"Fundamentally, JSX just provides syntactic sugar for the code line JSX.createElement(component, props, ...children) function. The transformation and conversion to JavaScript is made by the TypeScript transpiler. In case you use pure JavaScript, the best tool to compile JSX is Babel. Be aware, that while the main framework with native JSX support is React, @nyaf has absolutely no relation to React, and the behavior of the code is different.","title":"JSX / TSX"},{"location":"md/docs/lib/jsx/#introduction","text":"The next examples assume that some code surrounds the snippets or is just the return value of the render() method. See some TSX code used in a component: <my-button color=\"blue\" shadowSize={2}> Click Me </my-button> This piece of code compiles into the following function call: JSX.createElement( 'my-button', {color: 'blue', shadowSize: 2}, 'Click Me' )","title":"Introduction"},{"location":"md/docs/lib/jsx/#jsx-scope","text":"Since JSX compiles into calls to JSX.createElement , the JSX class must also always be in scope from your TSX code. For example, both of the imports are necessary in this code, even though React and CustomButton are not directly referenced from JavaScript: import JSX from '@nyaf/lib'; // code omitted for brevity render() { // return JSX.createElement('custom-button', {color: 'red'}, null); return (<custom-button color=\"red\" />); } Note that this is a default export, so no curly braces here! If you don\u2019t use a JavaScript bundler and load @nyaf from a <script> tag, it is already in scope as a global object named JSX . The elements used in the JSX parts are registered globally and there is no additional import required. That's a fundamentally different behavior in comparison to React. In React the first argument is a type and the elements will render itself based on the given type. In @nyaf the first argument is a string, and the constructed element is pushed to the browser as string through innerHTML , and the browser renders the content directly using native code.","title":"JSX Scope"},{"location":"md/docs/lib/jsx/#examples","text":"You can also use the self-closing form of the tag if there are no children. <div class=\"sidebar\" /> This piece of code compiles into this JavaScript: JSX.createElement('div', {'class': 'sidebar'}) If you want to test out how some specific JSX is converted into JavaScript, you can try out the online Babel compiler . Be aware that in case of any JSX oriented tools not explicitly configured for @nyaf may create the code with the namespace React . In fact, the online Babel transpiler creates something like this: React.createElement(\"div\", { class: \"sidebar\" }); That's pretty much the same, so it will work as learning tool, but keep the changed names in mind.","title":"Examples"},{"location":"md/docs/lib/jsx/#specifying-the-element-type","text":"The first part of a TSX tag determines the type of the element. It's the name of a registered Web Component.","title":"Specifying the Element Type"},{"location":"md/docs/lib/jsx/#web-components-must-be-in-kebab-style","text":"When an element type starts with a lowercase letter, it refers to a built-in component like <div> or <span> and results in a string 'div' or 'span' passed to JSX.createElement . Types that have a dashed name like <my-foo /> compile to JSX.createElement('my-foo') and correspond to a component defined globally through GlobalProvider . We recommend naming components always with kebab style.","title":"Web Components Must be in Kebab Style"},{"location":"md/docs/lib/jsx/#properties-in-tsx","text":"There are several different ways to specify properties in TSX.","title":"Properties in TSX"},{"location":"md/docs/lib/jsx/#javascript-expressions-as-properties","text":"You can pass any JavaScript expression as a property, by surrounding it with curly braces ( {} ). For example, see this TSX: <my-component foo={1 + 2 + 3 + 4} /> For 'my-component', the value of props.foo will be 10 because the expression 1 + 2 + 3 + 4 gets evaluated. if statements and for loops are not expressions in JavaScript, so they can\u2019t be used in TSX directly. Instead, you can put these in the surrounding code. For example see this snippet from a component class: NumberDescriber(props): string { let description; if (props.number % 2 == 0) { description = <strong>even</strong>; } else { description = <i>odd</i>; } return (<div>{props.number} is an {description} number</div>); } This method uses TSX expressions directly in the code. There is no relation with the render method, the expressions can appear everywhere and they will return always string value. You can learn more about conditional rendering and loops in the corresponding sections.","title":"JavaScript Expressions as Properties"},{"location":"md/docs/lib/jsx/#string-literals","text":"You can pass a string literal as a property. These two TSX expressions are equivalent: <my-component message=\"hello world\" /> <my-component message={'hello world'} /> When you pass a string literal, its value is HTML-unescaped. So these two TSX expressions are equivalent: <my-component message=\"&lt;3\" /> <my-component message={'<3'} /> This behavior is usually not relevant. It\u2019s only mentioned here for completeness.","title":"String Literals"},{"location":"md/docs/lib/jsx/#properties-default-to-true","text":"If you pass no value for a property, it defaults to true. These two TSX expressions are equivalent: <my-textbox autocomplete /> <my-textbox autocomplete={true} /> In general, we don\u2019t recommend not passing a value for a property, because it can be confused with the ES2015 object shorthand {foo} which is short for {foo: foo} rather than {foo: true} . This behavior is just there so that it matches the behavior of HTML.","title":"Properties Default to True"},{"location":"md/docs/lib/jsx/#spread-attributes","text":"If you already have properties as an object, and you want to pass it in JSX, you can use ... as a \u201cspread\u201d operator to pass the whole object. These two methods are equivalent: getApp1(): string { return <app-greeting firstName=\"Joerg\" lastName=\"Krause\" />; } getApp2(): string { const props = {firstName: 'Joerg', lastName: 'Krause'}; return <app-greeting {...props} />; } You can also pick specific properties that your component will consume while passing all other props using the spread operator. const Button = props => { const { kind, ...other } = props; const cls = kind === \"primary\" ? \"PrimaryButton\" : \"SecondaryButton\"; return <button class={cls} {...other} />; }; const getApp = () => { return ( <div> <Button kind=\"primary\" onClick={() => console.log(\"clicked!\")}> Hello World! </Button> </div> ); }; In the example above, the kind property is safely consumed and is not passed on to the <button> element in the DOM. All other properties are passed via the ...other object making this component really flexible. You can see that it passes an onClick and children properties. Spread attributes can be useful but they also make it easy to pass unnecessary properties to components that don\u2019t care about them or to pass invalid HTML attributes to the DOM. It's recommended using this syntax sparingly.","title":"Spread Attributes"},{"location":"md/docs/lib/jsx/#children-in-tsx","text":"In TSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special property this.children . There are several different ways to pass children.","title":"Children in TSX"},{"location":"md/docs/lib/jsx/#string-literals_1","text":"You can put a string between the opening and closing tags and this.children will just be that string. This is useful for many of the built-in HTML elements. For example: <my-component>Hello world!</my-component> This is valid TSX, and this.children in MyComponent will simply be the string \"Hello world!\". HTML is unescaped, so you can generally write TSX just like you would write HTML in this way: <div>This is valid HTML &amp; TSX at the same time.</div> TSX removes whitespace at the beginning and ending of a line. It also removes blank lines. New lines adjacent to tags are removed; new lines that occur in the middle of string literals are condensed into a single space. So these all render to the same thing: <div>Hello World</div> <div> Hello World </div> <div> Hello World </div> <div> Hello World </div>","title":"String Literals"},{"location":"md/docs/lib/jsx/#tsx-children","text":"You can provide more TSX elements as the children. This is useful for displaying nested components: <my-container> <my-first-component /> <my-second-component /> </my-container> You can mix together different types of children, so you can use string literals together with TSX children. This is another way in which TSX is like HTML, so that this is both valid JSX and valid HTML: <div> Here is a list: <ul> <li>Item 1</li> <li>Item 2</li> </ul> </div>","title":"TSX Children"},{"location":"md/docs/lib/jsx/#expressions-as-children","text":"You can pass any JavaScript expression as children, by enclosing it within {} . For example, these expressions are equivalent: <my-component>foo</my-component> <my-component>{'foo'}</my-component> This is often useful for rendering a list of JSX expressions of arbitrary length. For example, this renders an HTML list: Item(data: { message: string }): string { return <li>{data.message}</li>; } todoList(): string { const todos = ['create tests', 'fix bugs', 'attend scrum']; return ( <ul> {todos.map((msg) => <my-item message={message} />)} </ul> ); } JavaScript expressions can be mixed with other types of children. This is often useful in lieu of string templates: hello(data: { addressee: string }): string { return <div>Hello {data.addressee}!</div>; }","title":"Expressions as Children"},{"location":"md/docs/lib/jsx/#booleans-null-and-undefined","text":"The values false , null , undefined , and true are valid children. They simply don\u2019t render. These TSX expressions will all render to the same thing: <div /> <div></div> <div>{false}</div> <div>{null}</div> <div>{undefined}</div> <div>{true}</div> This can be useful to conditionally render elements. This TSX renders the component only if showHeader is true : <div> {showHeader && <app-header />} <app-content /> </div> One caveat is that some \u201cfalsy\u201d values, such as the 0 number, are still rendered by React. For example, this code will not behave as you might expect because 0 will be printed when data.messages is an empty array: <div> {this.data.messages.length && <message-list messages={this.data.messages} /> } </div> To fix this, make sure that the expression before && is always boolean : <div> {this.data.messages.length > 0 && <message-list messages={this.data.messages} /> } </div> Conversely, if you want a value like false , true , null , or undefined to appear in the output, you have to convert it to a string first: <div> The JavaScript variable is {String(myVariable)}. </div>","title":"Booleans, Null, and Undefined"},{"location":"md/docs/lib/lifecycle/","text":"The Life Cycle # Components have a life cycle. Instead of several events, there is just one method you must override (or ignore if not needed): lifeCycle(cycle: LifeCycle){ if (cycle === LifeCycle.Load){ // it's ready to go } } Note, that the method has lower case \"l\". The LifeCycle -enum (upper case \"L\") has these fields: Init : Start, the constructor is called. Connect : Component connects to backend SetData : A change in the data object occurred. Load : The render process is done and the component has been loaded PreRender : The render method has been called and content is not yet written to innerHTML . Disconnect : Component is going to be unloaded. Disposed : After calling the dispose method. The life cycle is also available through an event lifecycle . It's exposed via a property called onlifecycle on the element level, too. The events are fired after the internal hook has been called.","title":"Life Cycle"},{"location":"md/docs/lib/lifecycle/#the-life-cycle","text":"Components have a life cycle. Instead of several events, there is just one method you must override (or ignore if not needed): lifeCycle(cycle: LifeCycle){ if (cycle === LifeCycle.Load){ // it's ready to go } } Note, that the method has lower case \"l\". The LifeCycle -enum (upper case \"L\") has these fields: Init : Start, the constructor is called. Connect : Component connects to backend SetData : A change in the data object occurred. Load : The render process is done and the component has been loaded PreRender : The render method has been called and content is not yet written to innerHTML . Disconnect : Component is going to be unloaded. Disposed : After calling the dispose method. The life cycle is also available through an event lifecycle . It's exposed via a property called onlifecycle on the element level, too. The events are fired after the internal hook has been called.","title":"The Life Cycle"},{"location":"md/docs/lib/overview/","text":"Components # Components are the core ingredients. You write components as classes, decorated with the decorator CustomElement . This defines a Web Component . The component must be registered, then. This is done by calling the static method GlobalProvider.bootstrap . Registration Support # To support the registration as mentioned before we use decorators. This makes it quite easy to define a component without knowing the details of the browser's API. The name is determined by @CustomElement('my-name') . This is mandatory. The name shall follow the common rules of Web Components, that means, it must have at least one dash '-' so there is no risk of a collision with common HTML element names. import JSX, { CustomElement } from '@nyaf/lib'; @CustomElement('app-main') export class MainComponent extends BaseComponent<{}> { constructor() { super(); } render() { return ( <> <h1>Demo</h1> </> ); } } Let's go step by step through this simple component. First, the import includes not only the decorator, but the type JSX too. That's necessary, if you want to use JSX (or TSX) and let the TypeScript compiler translate the HTML syntax properly. The supporting class comes from @nyaf/lib and has absolutely no relation to React. It has, in some details, a different behavior compared with the JSX used in React. The import is necessary, even if there is no explicit usage in the module. Both, the TypeScript transpiler and linter (such as TSLint ) know about this and will not complain. Second, the component has a base class. All @nyaf components are derived from HTMLElement . Currently we don't support inheriting from other element types. Note also the usage of a base class, which gets a generic that later controls the access to the attributes. Now, that the component is defined, it must be registered. In a file called main.ts (or wherever your app is bootstrapped) call this: import { GlobalProvider } from '@nyaf/lib'; import { MainComponent } from './components/main.component'; GlobalProvider.bootstrap({ components: [MainComponent] }); That's it, the component works now. Use it in the HTML part, usually called .index.html : <body class=\"container\"> <app-main></app-main> </body> Once you have more components, it may look like this: GlobalProvider.bootstrap({ components: [ ButtonComponent, TabComponent, TabsComponent, MainComponent ] }); The First Component # This section describes how to bring the component to live. I assume that you have already a typical TypeScript setup with tsconfig.json , package.json , and your favorite packer. Create a file main.ts in the src folder that looks like this: import { GlobalProvider } from '@nyaf/lib'; import { MainComponent } from './main.component'; GlobalProvider.bootstrap({ components: [MainComponent], }); Create file main.component.tsx in the same folder (It must be *.tsx if you use JSX). Fill this content in: import JSX, { BaseComponent, CustomElement } from '@nyaf/lib'; @CustomElement('app-main') export class MainComponent extends BaseComponent { constructor() { super(); } render() { return ( <section> <h2>Demo</h2> <p>Hello nyaf</p> </section> ); } } Watch the default import for JSX - this is required, even if there is no explicit call. The TypeScript transpiler needs this when handling JSX files. It's always JSX , even if we use *.tsx -files. Create a file named index.html in the very same folder and fill it like this: <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> <title>Hello nyaf</title> </head> <body> <h1>Hello nyaf</h1> <app-main></app-main> <!-- script goes here, either by packer or manually --> </body> </html> Your app starts in line 10. Using the packer configuration you get the index.html file in the ./dist folder, a bundle, and a reference to this bundle to load the script. If you pack manually or keep the scripts separately add the script tags before the closing <body> element.","title":"Overview"},{"location":"md/docs/lib/overview/#components","text":"Components are the core ingredients. You write components as classes, decorated with the decorator CustomElement . This defines a Web Component . The component must be registered, then. This is done by calling the static method GlobalProvider.bootstrap .","title":"Components"},{"location":"md/docs/lib/overview/#registration-support","text":"To support the registration as mentioned before we use decorators. This makes it quite easy to define a component without knowing the details of the browser's API. The name is determined by @CustomElement('my-name') . This is mandatory. The name shall follow the common rules of Web Components, that means, it must have at least one dash '-' so there is no risk of a collision with common HTML element names. import JSX, { CustomElement } from '@nyaf/lib'; @CustomElement('app-main') export class MainComponent extends BaseComponent<{}> { constructor() { super(); } render() { return ( <> <h1>Demo</h1> </> ); } } Let's go step by step through this simple component. First, the import includes not only the decorator, but the type JSX too. That's necessary, if you want to use JSX (or TSX) and let the TypeScript compiler translate the HTML syntax properly. The supporting class comes from @nyaf/lib and has absolutely no relation to React. It has, in some details, a different behavior compared with the JSX used in React. The import is necessary, even if there is no explicit usage in the module. Both, the TypeScript transpiler and linter (such as TSLint ) know about this and will not complain. Second, the component has a base class. All @nyaf components are derived from HTMLElement . Currently we don't support inheriting from other element types. Note also the usage of a base class, which gets a generic that later controls the access to the attributes. Now, that the component is defined, it must be registered. In a file called main.ts (or wherever your app is bootstrapped) call this: import { GlobalProvider } from '@nyaf/lib'; import { MainComponent } from './components/main.component'; GlobalProvider.bootstrap({ components: [MainComponent] }); That's it, the component works now. Use it in the HTML part, usually called .index.html : <body class=\"container\"> <app-main></app-main> </body> Once you have more components, it may look like this: GlobalProvider.bootstrap({ components: [ ButtonComponent, TabComponent, TabsComponent, MainComponent ] });","title":"Registration Support"},{"location":"md/docs/lib/overview/#the-first-component","text":"This section describes how to bring the component to live. I assume that you have already a typical TypeScript setup with tsconfig.json , package.json , and your favorite packer. Create a file main.ts in the src folder that looks like this: import { GlobalProvider } from '@nyaf/lib'; import { MainComponent } from './main.component'; GlobalProvider.bootstrap({ components: [MainComponent], }); Create file main.component.tsx in the same folder (It must be *.tsx if you use JSX). Fill this content in: import JSX, { BaseComponent, CustomElement } from '@nyaf/lib'; @CustomElement('app-main') export class MainComponent extends BaseComponent { constructor() { super(); } render() { return ( <section> <h2>Demo</h2> <p>Hello nyaf</p> </section> ); } } Watch the default import for JSX - this is required, even if there is no explicit call. The TypeScript transpiler needs this when handling JSX files. It's always JSX , even if we use *.tsx -files. Create a file named index.html in the very same folder and fill it like this: <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> <title>Hello nyaf</title> </head> <body> <h1>Hello nyaf</h1> <app-main></app-main> <!-- script goes here, either by packer or manually --> </body> </html> Your app starts in line 10. Using the packer configuration you get the index.html file in the ./dist folder, a bundle, and a reference to this bundle to load the script. If you pack manually or keep the scripts separately add the script tags before the closing <body> element.","title":"The First Component"},{"location":"md/docs/lib/router/","text":"Router # Usually we create SPAs (Single Page Apps). Hence we need a router. The included router is very simple. First, define an outlet where the components appear: <div n-router-outlet></div> Any kind of parent element will do. The router code sets the property innerHTML . Components, that are being used to provide router content need registration too. They must have a name, too, because that's the way the router internally activates the component. There is just one default outlet. See further below for using named outlets. Register Routes # The following code shows how to register routes: let routes = { '/': { component: DemoComponent }, '/about': { component: AboutComponent }, '/demo': { component: DemoComponent }, '/contact': { component: ContactComponent }, '**': { component: DemoComponent } }; GlobalProvider.bootstrap({ components: [ DemoComponent, AboutComponent, ContactComponent, MainComponent ], routes: routes }); The first entry '/': { component: DemoComponent }, shall always exist, it's the default route loaded on start. It's being recognized by the '/' key (the position in the array doesn't matter). The entry '**': { component: DemoComponent } is optional and defines a fallback in case an invalid path is being used. You can shorten the property in the bootstrap script, too: const components = [ DemoComponent, AboutComponent, ContactComponent, MainComponent ]; GlobalProvider.bootstrap({ components, routes }); Using Routes # To activate a router you need a hyperlink. The router's code looks for a click onto an anchor tag. An appropriate code snippet to use the routes looks like this: <a href=\"#/\" n-link>Home</a> <a href=\"#/about\" n-link>About</a> <a href=\"#/demo\" n-link>Demo</a> <a href=\"#/contact\" n-link>Contact</a> <div n-router-outlet></div> The important part here is the n-link attribute. Using this you can distinguish between navigation links for routing and any other anchor tag. You can also use a <button> element or any other. Internally it's just a click -event that's handled and that checks for the attribute, then. Please note the hash sign (#). It's required. No code or strategies here, write it by yourself and then enjoy the very small footprint of the outcome. Pro Tip! Import the router definition and use additional fields to create a menu directly from router configuration. If you have some sort of CSS framework running that provides support for menu navigation by classes, just add the class for the currently active element to the n-link attribute like this: <a href=\"#/\" n-link=\"active\">Home</a> <a href=\"#/about\" n-link=\"active\">About</a> <a href=\"#/demo\" n-link=\"active\">Demo</a> <a href=\"#/contact\" n-link=\"active\">Contact</a> <div n-router-outlet></div> After this, by clicking the hyperlink, the class \"active\" will be added to the anchor tag. Any click on any n-link decorated tag will remove all these classes from all these elements, first. The class' name can differ and you can add multiple classes. It's treated as string internally. Named Routes # The underlying route definition, the type Routes , allows two additional fields ( outlet and data ): const routes: Routes = { '/': { component: HomeComponent, outlet: 'main' }, '/docu': { component: DocuComponent, outlet: 'main', data: { notlocal: true} }, '/about': { component: AboutComponent, outlet: 'main' }, '/demo': { component: DemoComponent, outlet: 'main', '/router': { component: RouterComponent, outlet: 'main' }, '/router/page1': { component: Page1Component, outlet: 'router' }, '/router/page2': { component: Page2Component, outlet: 'router' }, '/router/page2/other': { component: Page2Component, outlet: 'other' }, '/router/page3/other': { component: Page3Component, outlet: 'other' }, '/contact': { component: ContactComponent } }; With outlet you can define a named outlet. If you use this, you must name all routes as there is no fallback currently. The route outlet might reside everywhere. It may look like this: <div n-router-outlet=\"other\"></div> If the route's components deliver <li> elements, you can also use something like this to build well formatted HTML: <ul n-router-outlet=\"other\"></div> There is no difference on the link side, the decision to address another outlet is made in the configuration only. If the outlet doesn't exist nothing happens and a warning appears on the console (in DEBUG mode). In the example I use routes that look like child routes. That's a hint for the intended behavior, but it's technically not necessary doing so. The resolver is very simple and doesn't care about routes, it's just matching the string and seeking the outlet. Additional Data # The last example showed another field data . This is a dictionary with arbitrary data just stored here. If you setup a navigation dynamically based on the configuration data you can control the behavior in a well defined way. However, there is no code intercepting these data, it's the task of the implementer to do something useful here. Special Values # If you use data: { title: 'Some Title' } the value in the field title is being copied to the websites title field. That way it appears on the tab (or header bar in Electron). If it's omitted, it's not being set at all. Navigate to Route # You can navigate by code: GlobalProvider.navigateRoute('/my-route'); The outlet is pulled from configuration, but if provided as second parameter it can be overwritten. Hint: In the link elements you use the '#' prefix. In the navigateRoute method this is not necessary and hence not allowed. Route Events # The router fires two events, available through the static GlobalProvider class like this: GlobalProvider.routerAction.addEventListener('navigate', (evt) => { const route = evt.detail; evt.cancel = true; // optionally cancel before execution } GlobalProvider.routerAction.addEventListener('navigated', (evt) => { const route = evt.detail; // this event can't be cancelled } If you have a dynamic component and you set the event handler, don't forget to remove the event handler in the dispose callback.","title":"Router"},{"location":"md/docs/lib/router/#router","text":"Usually we create SPAs (Single Page Apps). Hence we need a router. The included router is very simple. First, define an outlet where the components appear: <div n-router-outlet></div> Any kind of parent element will do. The router code sets the property innerHTML . Components, that are being used to provide router content need registration too. They must have a name, too, because that's the way the router internally activates the component. There is just one default outlet. See further below for using named outlets.","title":"Router"},{"location":"md/docs/lib/router/#register-routes","text":"The following code shows how to register routes: let routes = { '/': { component: DemoComponent }, '/about': { component: AboutComponent }, '/demo': { component: DemoComponent }, '/contact': { component: ContactComponent }, '**': { component: DemoComponent } }; GlobalProvider.bootstrap({ components: [ DemoComponent, AboutComponent, ContactComponent, MainComponent ], routes: routes }); The first entry '/': { component: DemoComponent }, shall always exist, it's the default route loaded on start. It's being recognized by the '/' key (the position in the array doesn't matter). The entry '**': { component: DemoComponent } is optional and defines a fallback in case an invalid path is being used. You can shorten the property in the bootstrap script, too: const components = [ DemoComponent, AboutComponent, ContactComponent, MainComponent ]; GlobalProvider.bootstrap({ components, routes });","title":"Register Routes"},{"location":"md/docs/lib/router/#using-routes","text":"To activate a router you need a hyperlink. The router's code looks for a click onto an anchor tag. An appropriate code snippet to use the routes looks like this: <a href=\"#/\" n-link>Home</a> <a href=\"#/about\" n-link>About</a> <a href=\"#/demo\" n-link>Demo</a> <a href=\"#/contact\" n-link>Contact</a> <div n-router-outlet></div> The important part here is the n-link attribute. Using this you can distinguish between navigation links for routing and any other anchor tag. You can also use a <button> element or any other. Internally it's just a click -event that's handled and that checks for the attribute, then. Please note the hash sign (#). It's required. No code or strategies here, write it by yourself and then enjoy the very small footprint of the outcome. Pro Tip! Import the router definition and use additional fields to create a menu directly from router configuration. If you have some sort of CSS framework running that provides support for menu navigation by classes, just add the class for the currently active element to the n-link attribute like this: <a href=\"#/\" n-link=\"active\">Home</a> <a href=\"#/about\" n-link=\"active\">About</a> <a href=\"#/demo\" n-link=\"active\">Demo</a> <a href=\"#/contact\" n-link=\"active\">Contact</a> <div n-router-outlet></div> After this, by clicking the hyperlink, the class \"active\" will be added to the anchor tag. Any click on any n-link decorated tag will remove all these classes from all these elements, first. The class' name can differ and you can add multiple classes. It's treated as string internally.","title":"Using Routes"},{"location":"md/docs/lib/router/#named-routes","text":"The underlying route definition, the type Routes , allows two additional fields ( outlet and data ): const routes: Routes = { '/': { component: HomeComponent, outlet: 'main' }, '/docu': { component: DocuComponent, outlet: 'main', data: { notlocal: true} }, '/about': { component: AboutComponent, outlet: 'main' }, '/demo': { component: DemoComponent, outlet: 'main', '/router': { component: RouterComponent, outlet: 'main' }, '/router/page1': { component: Page1Component, outlet: 'router' }, '/router/page2': { component: Page2Component, outlet: 'router' }, '/router/page2/other': { component: Page2Component, outlet: 'other' }, '/router/page3/other': { component: Page3Component, outlet: 'other' }, '/contact': { component: ContactComponent } }; With outlet you can define a named outlet. If you use this, you must name all routes as there is no fallback currently. The route outlet might reside everywhere. It may look like this: <div n-router-outlet=\"other\"></div> If the route's components deliver <li> elements, you can also use something like this to build well formatted HTML: <ul n-router-outlet=\"other\"></div> There is no difference on the link side, the decision to address another outlet is made in the configuration only. If the outlet doesn't exist nothing happens and a warning appears on the console (in DEBUG mode). In the example I use routes that look like child routes. That's a hint for the intended behavior, but it's technically not necessary doing so. The resolver is very simple and doesn't care about routes, it's just matching the string and seeking the outlet.","title":"Named Routes"},{"location":"md/docs/lib/router/#additional-data","text":"The last example showed another field data . This is a dictionary with arbitrary data just stored here. If you setup a navigation dynamically based on the configuration data you can control the behavior in a well defined way. However, there is no code intercepting these data, it's the task of the implementer to do something useful here.","title":"Additional Data"},{"location":"md/docs/lib/router/#special-values","text":"If you use data: { title: 'Some Title' } the value in the field title is being copied to the websites title field. That way it appears on the tab (or header bar in Electron). If it's omitted, it's not being set at all.","title":"Special Values"},{"location":"md/docs/lib/router/#navigate-to-route","text":"You can navigate by code: GlobalProvider.navigateRoute('/my-route'); The outlet is pulled from configuration, but if provided as second parameter it can be overwritten. Hint: In the link elements you use the '#' prefix. In the navigateRoute method this is not necessary and hence not allowed.","title":"Navigate to Route"},{"location":"md/docs/lib/router/#route-events","text":"The router fires two events, available through the static GlobalProvider class like this: GlobalProvider.routerAction.addEventListener('navigate', (evt) => { const route = evt.detail; evt.cancel = true; // optionally cancel before execution } GlobalProvider.routerAction.addEventListener('navigated', (evt) => { const route = evt.detail; // this event can't be cancelled } If you have a dynamic component and you set the event handler, don't forget to remove the event handler in the dispose callback.","title":"Route Events"},{"location":"md/docs/lib/select/","text":"Select Elements # Using the HTML 5 API can result in a lot of API calls. Instead of using querySelector in the component's code, use a decorator: @Select('#queryId') elementName; The element is filled with the real object, then. In case you have a selector that returns many elements, the decorator uses querySelectorAll internally and returns an object of type QueryList<T> . This is an interface and it is defined like this: interface QueryList<T extends HTMLElement> { length: number; first: T; last: T; items: T[]; } The decorator logic takes care of the existence of a shadow DOM and acts accordingly. You can enforce the creation of a list with a second parameter many . If set to true , the result is always a list with QueryList , regardless the number of elements. @Select('a[href]', true) links; // later in code const count = this.links.length; Using Element Types # Use types to access type specific properties: @Select('#queryId') elementName: HTMLElement; @Select('button') buttons: QueryList<HTMLButtonElement>;","title":"Select Elements"},{"location":"md/docs/lib/select/#select-elements","text":"Using the HTML 5 API can result in a lot of API calls. Instead of using querySelector in the component's code, use a decorator: @Select('#queryId') elementName; The element is filled with the real object, then. In case you have a selector that returns many elements, the decorator uses querySelectorAll internally and returns an object of type QueryList<T> . This is an interface and it is defined like this: interface QueryList<T extends HTMLElement> { length: number; first: T; last: T; items: T[]; } The decorator logic takes care of the existence of a shadow DOM and acts accordingly. You can enforce the creation of a list with a second parameter many . If set to true , the result is always a list with QueryList , regardless the number of elements. @Select('a[href]', true) links; // later in code const count = this.links.length;","title":"Select Elements"},{"location":"md/docs/lib/select/#using-element-types","text":"Use types to access type specific properties: @Select('#queryId') elementName: HTMLElement; @Select('button') buttons: QueryList<HTMLButtonElement>;","title":"Using Element Types"},{"location":"md/docs/lib/services/","text":"Services # Services can be injected by two decorators, one on class level and one on property level. The motivation behind services is a technique called Dependency Injection . It's a key ingredient to create testable components. Dependency Injection # When developing Web Components you will ask yourself at some point, where to actually get the data and configuration from. If you are used to frameworks like Angular, you know that you can inject services and configurations. Web Components rely on HTML attributes, JavaScript properties and CustomEvent for input/outputs. But, what if we use that, to build our own dependency injection to share along with services and configuration? In this deep dive, we are going to experiment and not only see if it is possible but also if it makes sense. In the blog series about Web Components, we talked a lot about the perks and flaws of Web Components (or: the current state of Web Components) and how their integrability in modern SPA frameworks looks like. But we only took a short look at Web Components being integrated as a single stand-alone component into other environments. Even with all the flaws, Web Components provide a good-enough foundation to write full applications. For example, our colleague Christian Liebel implemented a web version of Microsoft Paint with Web Components and the help of LitElement. Especially in the last part of the above-mentioned blog series, we addressed sharing data and common services. If you have a good sense of software architecture, your first thought might be that you can solve sharing data and services via the dependency injection (DI) approach. That is why we want to explore the idea of DI and Web Components in this blog post. The Idea Behind Dependency Injection # If you are familiar with DI, you can skip this section. As a little reminder, let's talk about dependency injection in general, without going too deep into this (because many great blog posts out there are describing DI). See the following, non-DI approach: export class WordDocument extends BaseComponent { constructor() { this.spellChecker = new GermanSpellChecker(); } spellCheck() { this.spellChecker.perform(); } } In this example, we have a class WordDocument that itself creates a GermanSpellChecker. By that, they are strongly tied together. If you create an instance of WordDocument, you will always have a GermanSpellChecker. As you can guess, that's not what you want to have all the time. To change that, we have to invert the control, like this: export class WordDocument extends BaseComponent{ constructor(spellChecker: SpellChecker) { this.spellChecker = spellChecker; } // ... } // Example const germanDocument = new WordDocument(new GermanSpellChecker()); const englishDocument = new WordDocument(new EnglishSpellChecker()); const frenchDocument = new WordDocument(new FrenchSpellChecker()); If someone wants to create an instance of WordDocument, they also have to provide a spell checker. The big difference is that the caller now can decide which kind of spell checker they want to have, thus we are inverting the control here. That makes our class much more flexible, and you can implement any language for spell checking. The more dependencies the WordDocument has, the more cumbersome it gets to create each of the dependencies (which also could have dependencies on their own). At this point, you normally introduce a dependency injection container, that, as a straightforward explanation, has a list of classes and automatically creates the instances for you: container.register(WordDocument); container.register(GermanSpellChecker); // ... const document = container.resolve(WordDocument); The container takes care of how to create an instance of WordDocument with all its dependencies. Since we are using the constructor to inject the dependency, it is also called constructor injection. Web Components & Dependency Injection In general, all components share the concept of having inputs and outputs. According to Web Components, we can use HTML attributes and JavaScript properties as inputs and dispatch custom events as outputs. If you want to stay 100 % compatible with the Web Components specification, there is no other possibility to communicate with the Web Component's surroundings. If you plan to embed your Web Components on any page, you should also follow the specification. But if you plan to build a whole application with Web Components, you can think of other possibilities to communicate and develop your Web Components. Creating an entire application means that you have everything under control. You know your components, your data, your services, and your use cases. And you can create all your classes in a way that they fit together perfectly. Under such circumstances, it is possible to create a dependency injection system that works kind of well with Web Components. And it can even be a hierarchical DI system, that allows a child component to override a parent component's container registry. Using @InjectService # Once in a while we need to get access to an injectable service. That's also a task for a decorator to extract that kind of infrastructure code from the component's body. @CustomElement('app-main') @InjectService('localNameA', ServiceClass1) @InjectService('localNameB', ServiceClass2.instance, true) export class MainComponent extends BaseComponent<{}> { // ... omitted for brevity render() { let data = await this.services('localNameA').callAnyServiceFunctionHereAsync(); } } this.services is a function, that returns an instance of the service. Services are singleton on the level of the local name. The same name used in different components will return the same instance. Using a different name will create a new instance. Async is an option, can by sync, too. However, the render process is always asynchronous internally. The third option of @InjectService allows to define a singleton. Instead of providing a type for the second parameter of the decorator, here you must provide an instance. The same name will be shared across components. To get help with types, you can use a generic on the services function: this.services<ServiceClass1>('localNameA'); Using @Inject # If you provide this decorator directly on a property, the service is available through this property. The name is no longer needed. @CustomElement('app-main') export class MainComponent extends BaseComponent<{}> { @Inject<ServiceClass1>(ServiceClass1) serviceField; someActionMethod(): void { this.serviceField.actionOnService(); } } Usage Scenarios # Injectable services can be any of these, just to give a few ideas: Translation Service Logger Service HTTP Service As a definition, it's often something that is not clearly bound to a specific component. If it's a global piece of business logic, it would better fit into a global store as a set of reducers. That's what the @nyaf/store module is for. But id it's a technical service, a common function, of just infrastructure, a service is a much better way to implement.","title":"Services"},{"location":"md/docs/lib/services/#services","text":"Services can be injected by two decorators, one on class level and one on property level. The motivation behind services is a technique called Dependency Injection . It's a key ingredient to create testable components.","title":"Services"},{"location":"md/docs/lib/services/#dependency-injection","text":"When developing Web Components you will ask yourself at some point, where to actually get the data and configuration from. If you are used to frameworks like Angular, you know that you can inject services and configurations. Web Components rely on HTML attributes, JavaScript properties and CustomEvent for input/outputs. But, what if we use that, to build our own dependency injection to share along with services and configuration? In this deep dive, we are going to experiment and not only see if it is possible but also if it makes sense. In the blog series about Web Components, we talked a lot about the perks and flaws of Web Components (or: the current state of Web Components) and how their integrability in modern SPA frameworks looks like. But we only took a short look at Web Components being integrated as a single stand-alone component into other environments. Even with all the flaws, Web Components provide a good-enough foundation to write full applications. For example, our colleague Christian Liebel implemented a web version of Microsoft Paint with Web Components and the help of LitElement. Especially in the last part of the above-mentioned blog series, we addressed sharing data and common services. If you have a good sense of software architecture, your first thought might be that you can solve sharing data and services via the dependency injection (DI) approach. That is why we want to explore the idea of DI and Web Components in this blog post.","title":"Dependency Injection"},{"location":"md/docs/lib/services/#the-idea-behind-dependency-injection","text":"If you are familiar with DI, you can skip this section. As a little reminder, let's talk about dependency injection in general, without going too deep into this (because many great blog posts out there are describing DI). See the following, non-DI approach: export class WordDocument extends BaseComponent { constructor() { this.spellChecker = new GermanSpellChecker(); } spellCheck() { this.spellChecker.perform(); } } In this example, we have a class WordDocument that itself creates a GermanSpellChecker. By that, they are strongly tied together. If you create an instance of WordDocument, you will always have a GermanSpellChecker. As you can guess, that's not what you want to have all the time. To change that, we have to invert the control, like this: export class WordDocument extends BaseComponent{ constructor(spellChecker: SpellChecker) { this.spellChecker = spellChecker; } // ... } // Example const germanDocument = new WordDocument(new GermanSpellChecker()); const englishDocument = new WordDocument(new EnglishSpellChecker()); const frenchDocument = new WordDocument(new FrenchSpellChecker()); If someone wants to create an instance of WordDocument, they also have to provide a spell checker. The big difference is that the caller now can decide which kind of spell checker they want to have, thus we are inverting the control here. That makes our class much more flexible, and you can implement any language for spell checking. The more dependencies the WordDocument has, the more cumbersome it gets to create each of the dependencies (which also could have dependencies on their own). At this point, you normally introduce a dependency injection container, that, as a straightforward explanation, has a list of classes and automatically creates the instances for you: container.register(WordDocument); container.register(GermanSpellChecker); // ... const document = container.resolve(WordDocument); The container takes care of how to create an instance of WordDocument with all its dependencies. Since we are using the constructor to inject the dependency, it is also called constructor injection. Web Components & Dependency Injection In general, all components share the concept of having inputs and outputs. According to Web Components, we can use HTML attributes and JavaScript properties as inputs and dispatch custom events as outputs. If you want to stay 100 % compatible with the Web Components specification, there is no other possibility to communicate with the Web Component's surroundings. If you plan to embed your Web Components on any page, you should also follow the specification. But if you plan to build a whole application with Web Components, you can think of other possibilities to communicate and develop your Web Components. Creating an entire application means that you have everything under control. You know your components, your data, your services, and your use cases. And you can create all your classes in a way that they fit together perfectly. Under such circumstances, it is possible to create a dependency injection system that works kind of well with Web Components. And it can even be a hierarchical DI system, that allows a child component to override a parent component's container registry.","title":"The Idea Behind Dependency Injection"},{"location":"md/docs/lib/services/#using-injectservice","text":"Once in a while we need to get access to an injectable service. That's also a task for a decorator to extract that kind of infrastructure code from the component's body. @CustomElement('app-main') @InjectService('localNameA', ServiceClass1) @InjectService('localNameB', ServiceClass2.instance, true) export class MainComponent extends BaseComponent<{}> { // ... omitted for brevity render() { let data = await this.services('localNameA').callAnyServiceFunctionHereAsync(); } } this.services is a function, that returns an instance of the service. Services are singleton on the level of the local name. The same name used in different components will return the same instance. Using a different name will create a new instance. Async is an option, can by sync, too. However, the render process is always asynchronous internally. The third option of @InjectService allows to define a singleton. Instead of providing a type for the second parameter of the decorator, here you must provide an instance. The same name will be shared across components. To get help with types, you can use a generic on the services function: this.services<ServiceClass1>('localNameA');","title":"Using @InjectService"},{"location":"md/docs/lib/services/#using-inject","text":"If you provide this decorator directly on a property, the service is available through this property. The name is no longer needed. @CustomElement('app-main') export class MainComponent extends BaseComponent<{}> { @Inject<ServiceClass1>(ServiceClass1) serviceField; someActionMethod(): void { this.serviceField.actionOnService(); } }","title":"Using @Inject"},{"location":"md/docs/lib/services/#usage-scenarios","text":"Injectable services can be any of these, just to give a few ideas: Translation Service Logger Service HTTP Service As a definition, it's often something that is not clearly bound to a specific component. If it's a global piece of business logic, it would better fit into a global store as a set of reducers. That's what the @nyaf/store module is for. But id it's a technical service, a common function, of just infrastructure, a service is a much better way to implement.","title":"Usage Scenarios"},{"location":"md/docs/lib/shadowdom/","text":"Shadow DOM # By default the shadow DOM is _not _ used. If it would, it would mean, that styles are isolated. No global styles are available, then. One option to activate the Shadow DOM is using this decorator: @ShadowDOM() A parameter can be set explicitly. This is some kind of coding style, a more expressive form. @ShadowDOM(true | false) Another interesting option controls the style behavior: @UseParentStyles() The decorator ShadowDOM must be set, otherwise the decorator @UseParentStyle does nothing If active, it copies all global styles into component so they work as expected even in Shadow DOM It's a trade-off. The shadow DOM increases performance and brings isolation. Copying many styles decreases performance and contradicts isolation. See the following example for a common usage scenario: @CustomElement('app-contact') @ShadowDOM() @UseParentStyles() export class ContactComponent extends BaseComponent { // omitted for brevity } The shadow DOM goes well along with the usage of slots. A typical example is a Tabs Component that's shown next. Tabs are a form of navigation for web sites, similar to the browser's tabs. Example with Shadow DOM # First, we start with the definition of a single tab. Single Tab # import JSX, { BaseComponent, CustomElement, ShadowDOM, UseParentStyles, LifeCycle } from '@nyaf/lib'; @CustomElement('app-slot-tab') @ShadowDOM(true) export class SlotTabComponent extends BaseComponent<{}> { private _title: string; constructor() { super(); this.classList.add('hide'); } render() { return ( <div id={this.getAttribute('data-id')}> <slot></slot> </div> ); } public get title() { return this._title; } public set title(value) { this._title = value; } } The <slot> element is the content target. The id is used to address the tab (to open it, actually). Tabs Container # Second, look at the container that handles multiple tabs. import JSX, { BaseComponent, CustomElement, LifeCycle, Events, ShadowDOM, UseParentStyles, uuidv4 } from '@nyaf/lib'; interface TabStore { node: Node; targetId: string; id: string; } interface IMaterialTabsDefaultConfig { materialtabsDeferred?: number; deep?: boolean; fixedTabs?: boolean; clsComponent?: string; clsTab?: string; clsTabActive?: string; clsMarker?: string; onBeforeTabOpen?(); onTabOpen?(); onTabsScroll?(); onTabsCreate?(); }; // tslint:disable-next-line:max-classes-per-file @CustomElement('app-slot-tabs') @Events(['all']) @ShadowDOM(true) @UseParentStyles(true) export class SlotTabsComponent extends BaseComponent<{}> { private tabChildren: TabStore[] = []; constructor() { super(); } render() { let first = 0; const tabHeaders = Array.prototype .slice .call(this.children) .map((child: Element) => { const targetId: string = child.id ?? '_' + uuidv4(); child.setAttribute('id', targetId); this.tabChildren.push({ node: child, targetId, id: child.id }); return ( <li class='nav-item'> <a class={'nav-link ' + (0 === first++ ? 'active' : '')} href={`#${targetId}`} >{child.getAttribute('title')} </a> </li> ); }); return ( <> <ul role=\"nav\" class=\"nav nav-tabs\"> {tabHeaders} </ul> <div class='row'> <div class='col'> <slot></slot> </div> </div> </> ) } lifeCycle(lc: LifeCycle) { if (lc === LifeCycle.Load) { let first = 0; this.shadowRoot.querySelectorAll('li') .forEach(li => { li.addEventListener('click', (e: Event) => this.selectTab(e)); if (first === 0) { this.openTab(li.querySelector('a').getAttribute('href')); } first++; }); } } private selectTab(e: Event) { let targetId = (e.target as HTMLElement).getAttribute('href'); if (!targetId) { const innerA = (e.target as HTMLElement).querySelector('a'); if (innerA) { targetId = innerA.getAttribute('href'); } } this.openTab(targetId); e.preventDefault(); e.cancelBubble = true; return false; } async setTab(id: string): Promise<void> { const targetId = this.tabChildren .filter((child) => child.id === id) .shift() .targetId; // use shadowRoot because it is shadowed this.openTab(`#${targetId}`); return Promise.resolve(); } // the visible tabs are in the shadow-root, // the content is outside in the document private openTab(targetId: string) { const tabs = this.shadowRoot.querySelectorAll('li > a'); // const tab = this.querySelector<HTMLElement>(targetId); const a = this.shadowRoot.querySelector(`[href=\"${targetId}\"]`); // hide all const tabContent = this.querySelectorAll('app-slot-tab'); tabContent.forEach((t: HTMLElement) => { t.classList.add('d-none'); }); // deactivate all tabs.forEach(t => { t.classList.remove('active'); }); // activate a.classList.add('active'); // move the marker // make tabContent visible const currentTab = this.querySelector('app-slot-tab' + targetId); currentTab.classList.remove('d-none'); } } Usage of the Tabs # The usage is quite simple. Just add as many tabs as required: <app-slot-tabs id='demoTabs'> <app-slot-tab title='Store Counter' id='d1'> <app-store-counter id='s1' cnt={42}></app-store-counter> </app-slot-tab> <app-slot-tab title='Store Data' id='d2'> <app-store-data id='s2'></app-store-data> </app-slot-tab> </app-slot-tabs> Shadow DOM and Styles # The Shadow DOM provides full isolation. The @UseParentStyles decorator contradicts this. A better way is to include styles \"per component\". Have a look onto an example first: @CustomElement('app-directive') @ShadowDOM() export class DirectiveComponent extends BaseComponent<any> { render() { return ( <> <button type='button' directive='drag' part='drag-button'> Drag me around </button> <div directive='drop' part='drop-zone'> </div> </> ); } } The important part here is, despite the @ShadowDOM decorator, the part attribute. That makes the shadowed component accessible (penetrable) for special external styles using the ::part pseudo-selector. A stylesheet could than look like this: app-directive::part(drop-zone) { border: 1px solid silver; width: 100px; height: 100px; } app-directive::part(drag-button) { background-color: green; padding: 5px; } This style is provided globally, not as part of the component, but it applies to this component only and only in shadow mode. Note, that using the regular CSS syntax, such as app-directive[part=\"drop-zone\"] would not work, as this cannot penetrate the shadow DOM. This is not a feature of @nyaf ; it's default Web Component behavior. We face some issues with elder browser version that don't understand the ::part selector properly. Consider adding a polyfill if needed.","title":"Shadow DOM"},{"location":"md/docs/lib/shadowdom/#shadow-dom","text":"By default the shadow DOM is _not _ used. If it would, it would mean, that styles are isolated. No global styles are available, then. One option to activate the Shadow DOM is using this decorator: @ShadowDOM() A parameter can be set explicitly. This is some kind of coding style, a more expressive form. @ShadowDOM(true | false) Another interesting option controls the style behavior: @UseParentStyles() The decorator ShadowDOM must be set, otherwise the decorator @UseParentStyle does nothing If active, it copies all global styles into component so they work as expected even in Shadow DOM It's a trade-off. The shadow DOM increases performance and brings isolation. Copying many styles decreases performance and contradicts isolation. See the following example for a common usage scenario: @CustomElement('app-contact') @ShadowDOM() @UseParentStyles() export class ContactComponent extends BaseComponent { // omitted for brevity } The shadow DOM goes well along with the usage of slots. A typical example is a Tabs Component that's shown next. Tabs are a form of navigation for web sites, similar to the browser's tabs.","title":"Shadow DOM"},{"location":"md/docs/lib/shadowdom/#example-with-shadow-dom","text":"First, we start with the definition of a single tab.","title":"Example with Shadow DOM"},{"location":"md/docs/lib/shadowdom/#single-tab","text":"import JSX, { BaseComponent, CustomElement, ShadowDOM, UseParentStyles, LifeCycle } from '@nyaf/lib'; @CustomElement('app-slot-tab') @ShadowDOM(true) export class SlotTabComponent extends BaseComponent<{}> { private _title: string; constructor() { super(); this.classList.add('hide'); } render() { return ( <div id={this.getAttribute('data-id')}> <slot></slot> </div> ); } public get title() { return this._title; } public set title(value) { this._title = value; } } The <slot> element is the content target. The id is used to address the tab (to open it, actually).","title":"Single Tab"},{"location":"md/docs/lib/shadowdom/#tabs-container","text":"Second, look at the container that handles multiple tabs. import JSX, { BaseComponent, CustomElement, LifeCycle, Events, ShadowDOM, UseParentStyles, uuidv4 } from '@nyaf/lib'; interface TabStore { node: Node; targetId: string; id: string; } interface IMaterialTabsDefaultConfig { materialtabsDeferred?: number; deep?: boolean; fixedTabs?: boolean; clsComponent?: string; clsTab?: string; clsTabActive?: string; clsMarker?: string; onBeforeTabOpen?(); onTabOpen?(); onTabsScroll?(); onTabsCreate?(); }; // tslint:disable-next-line:max-classes-per-file @CustomElement('app-slot-tabs') @Events(['all']) @ShadowDOM(true) @UseParentStyles(true) export class SlotTabsComponent extends BaseComponent<{}> { private tabChildren: TabStore[] = []; constructor() { super(); } render() { let first = 0; const tabHeaders = Array.prototype .slice .call(this.children) .map((child: Element) => { const targetId: string = child.id ?? '_' + uuidv4(); child.setAttribute('id', targetId); this.tabChildren.push({ node: child, targetId, id: child.id }); return ( <li class='nav-item'> <a class={'nav-link ' + (0 === first++ ? 'active' : '')} href={`#${targetId}`} >{child.getAttribute('title')} </a> </li> ); }); return ( <> <ul role=\"nav\" class=\"nav nav-tabs\"> {tabHeaders} </ul> <div class='row'> <div class='col'> <slot></slot> </div> </div> </> ) } lifeCycle(lc: LifeCycle) { if (lc === LifeCycle.Load) { let first = 0; this.shadowRoot.querySelectorAll('li') .forEach(li => { li.addEventListener('click', (e: Event) => this.selectTab(e)); if (first === 0) { this.openTab(li.querySelector('a').getAttribute('href')); } first++; }); } } private selectTab(e: Event) { let targetId = (e.target as HTMLElement).getAttribute('href'); if (!targetId) { const innerA = (e.target as HTMLElement).querySelector('a'); if (innerA) { targetId = innerA.getAttribute('href'); } } this.openTab(targetId); e.preventDefault(); e.cancelBubble = true; return false; } async setTab(id: string): Promise<void> { const targetId = this.tabChildren .filter((child) => child.id === id) .shift() .targetId; // use shadowRoot because it is shadowed this.openTab(`#${targetId}`); return Promise.resolve(); } // the visible tabs are in the shadow-root, // the content is outside in the document private openTab(targetId: string) { const tabs = this.shadowRoot.querySelectorAll('li > a'); // const tab = this.querySelector<HTMLElement>(targetId); const a = this.shadowRoot.querySelector(`[href=\"${targetId}\"]`); // hide all const tabContent = this.querySelectorAll('app-slot-tab'); tabContent.forEach((t: HTMLElement) => { t.classList.add('d-none'); }); // deactivate all tabs.forEach(t => { t.classList.remove('active'); }); // activate a.classList.add('active'); // move the marker // make tabContent visible const currentTab = this.querySelector('app-slot-tab' + targetId); currentTab.classList.remove('d-none'); } }","title":"Tabs Container"},{"location":"md/docs/lib/shadowdom/#usage-of-the-tabs","text":"The usage is quite simple. Just add as many tabs as required: <app-slot-tabs id='demoTabs'> <app-slot-tab title='Store Counter' id='d1'> <app-store-counter id='s1' cnt={42}></app-store-counter> </app-slot-tab> <app-slot-tab title='Store Data' id='d2'> <app-store-data id='s2'></app-store-data> </app-slot-tab> </app-slot-tabs>","title":"Usage of the Tabs"},{"location":"md/docs/lib/shadowdom/#shadow-dom-and-styles","text":"The Shadow DOM provides full isolation. The @UseParentStyles decorator contradicts this. A better way is to include styles \"per component\". Have a look onto an example first: @CustomElement('app-directive') @ShadowDOM() export class DirectiveComponent extends BaseComponent<any> { render() { return ( <> <button type='button' directive='drag' part='drag-button'> Drag me around </button> <div directive='drop' part='drop-zone'> </div> </> ); } } The important part here is, despite the @ShadowDOM decorator, the part attribute. That makes the shadowed component accessible (penetrable) for special external styles using the ::part pseudo-selector. A stylesheet could than look like this: app-directive::part(drop-zone) { border: 1px solid silver; width: 100px; height: 100px; } app-directive::part(drag-button) { background-color: green; padding: 5px; } This style is provided globally, not as part of the component, but it applies to this component only and only in shadow mode. Note, that using the regular CSS syntax, such as app-directive[part=\"drop-zone\"] would not work, as this cannot penetrate the shadow DOM. This is not a feature of @nyaf ; it's default Web Component behavior. We face some issues with elder browser version that don't understand the ::part selector properly. Consider adding a polyfill if needed.","title":"Shadow DOM and Styles"},{"location":"md/docs/lib/smart/","text":"Smart Components # Some features do not require additional code, they just need a clever usage of the power of TypeScript and Web Components. To simplify your life, a few of these are predefined as integrated components - the Smart Components. Transparent Outlet n-outlet # This is another outlet that renders into nothing. Normally you would do this: <div n-router-outlet></div> But that would place your component in a DIV element. If this is disturbing, just use this: <n-outlet></n-outlet> Also, a named variety is available: <n-outlet name=\"main\"></n-outlet> Render Finisher n-finish # Web Components render according their lifecycle. However, if you have a mix of components and regular HTML elements, the behavior can be weird, because the regular elements doesn't have a lifetime. The best solution is to have a pure tree of web components. But if that is not possible and a predictable execution path is necessary, you need to tell the render engine when it's really safe to render the parent element. To do so, add the element <n-finish /> like this: render() { return ( <ul> <some-component></some-component> <li></li> <li></li> <li></li> <n-finish /> </ul> ) } In that example the component waits for the lifecycle events of some-component but will render everything else immediately. If some-component exposes <li> tags too, they could appear after the static ones. If the order matters, the <n-finish> element helps enforcing the execution order.","title":"Smart Components"},{"location":"md/docs/lib/smart/#smart-components","text":"Some features do not require additional code, they just need a clever usage of the power of TypeScript and Web Components. To simplify your life, a few of these are predefined as integrated components - the Smart Components.","title":"Smart Components"},{"location":"md/docs/lib/smart/#transparent-outlet-n-outlet","text":"This is another outlet that renders into nothing. Normally you would do this: <div n-router-outlet></div> But that would place your component in a DIV element. If this is disturbing, just use this: <n-outlet></n-outlet> Also, a named variety is available: <n-outlet name=\"main\"></n-outlet>","title":"Transparent Outlet n-outlet"},{"location":"md/docs/lib/smart/#render-finisher-n-finish","text":"Web Components render according their lifecycle. However, if you have a mix of components and regular HTML elements, the behavior can be weird, because the regular elements doesn't have a lifetime. The best solution is to have a pure tree of web components. But if that is not possible and a predictable execution path is necessary, you need to tell the render engine when it's really safe to render the parent element. To do so, add the element <n-finish /> like this: render() { return ( <ul> <some-component></some-component> <li></li> <li></li> <li></li> <n-finish /> </ul> ) } In that example the component waits for the lifecycle events of some-component but will render everything else immediately. If some-component exposes <li> tags too, they could appear after the static ones. If the order matters, the <n-finish> element helps enforcing the execution order.","title":"Render Finisher n-finish"},{"location":"md/docs/lib/template/","text":"Template Features # Template Features avoid using creepy JavaScript for interactions and branches. You can use any of the following: n-if , n-else n-hide , n-show n-on-<event> (see section Events ) n-expand n-if, n-else # The value will be evaluated and the element using this attribute does or does not render. <div class=\"main-header\" n-if={this.props.title !== 't1'}> <span>Any content will not render if container doesn't render</span> </div> If there is an else-branch it can direct to a slot template. <slot> elements are native web component parts. <div class=\"main-header\" n-if={this.props.title !== 't1'} n-else=\"noShow\"> <span>Any content will not render if container doesn't render</span> </div> <slot name=\"noShow\"> This is shown instead. </slot> n-hide, n-show # These attributes work the same as n-if , but just add an inline style display: none (or remove one) if true ( n-hide ) or false ( n-show ). n-expand # This attribute expands a group of HTML attributes. Imagine an element like this: <input type=\"text\" placeholder=\"Name\" role=\"search\" class=\"materialinput\" id=\"a1 /> You may need this several times, each with different id. Instead of repeating the whole set of attributes, an expander can be used to add the static parts. <input n-expand=\"search\" id=\"a1\" /> <input n-expand=\"search\" id=\"a2\" /> <input n-expand=\"search\" id=\"a3\" /> To define the expander shown above you create a class like this: @Expand(\"search\") export class SearchExpander extends Expander { constructor(){ super(); } 'type'=\"text\"; 'placeholder'=\"Name\"; 'role'=\"search\"; 'class'=\"materialinput\"; } And yes, these are equal signs in the class. The named 'quoted' properties are only required if the attribute name contains dashes. Finally, add the definition to the global provider: Globalprovider.bootstrap({ components: [...components], // as usual expanders: [SearchExpander] }) That's it, a lot less to write without the effort to create components. It's just text-replacement before the renderer grabs the content, so no performance impact at runtime. The expander logic does not perform any kebab-pascal conversion as some other tools do (that means, the name myProp does not appear as my-prop automatically). Quick Expanders # Quick expanders are even easier, but more for local expanding. const d = { 'type': \"text\"; 'placeholder': \"Name\"; 'role': \"search\"; 'class': \"materialinput\"; } <app-button {...d} /> It's just pure ECMAScript magic, no code from @nyaf required.","title":"Template Language"},{"location":"md/docs/lib/template/#template-features","text":"Template Features avoid using creepy JavaScript for interactions and branches. You can use any of the following: n-if , n-else n-hide , n-show n-on-<event> (see section Events ) n-expand","title":"Template Features"},{"location":"md/docs/lib/template/#n-if-n-else","text":"The value will be evaluated and the element using this attribute does or does not render. <div class=\"main-header\" n-if={this.props.title !== 't1'}> <span>Any content will not render if container doesn't render</span> </div> If there is an else-branch it can direct to a slot template. <slot> elements are native web component parts. <div class=\"main-header\" n-if={this.props.title !== 't1'} n-else=\"noShow\"> <span>Any content will not render if container doesn't render</span> </div> <slot name=\"noShow\"> This is shown instead. </slot>","title":"n-if, n-else"},{"location":"md/docs/lib/template/#n-hide-n-show","text":"These attributes work the same as n-if , but just add an inline style display: none (or remove one) if true ( n-hide ) or false ( n-show ).","title":"n-hide, n-show"},{"location":"md/docs/lib/template/#n-expand","text":"This attribute expands a group of HTML attributes. Imagine an element like this: <input type=\"text\" placeholder=\"Name\" role=\"search\" class=\"materialinput\" id=\"a1 /> You may need this several times, each with different id. Instead of repeating the whole set of attributes, an expander can be used to add the static parts. <input n-expand=\"search\" id=\"a1\" /> <input n-expand=\"search\" id=\"a2\" /> <input n-expand=\"search\" id=\"a3\" /> To define the expander shown above you create a class like this: @Expand(\"search\") export class SearchExpander extends Expander { constructor(){ super(); } 'type'=\"text\"; 'placeholder'=\"Name\"; 'role'=\"search\"; 'class'=\"materialinput\"; } And yes, these are equal signs in the class. The named 'quoted' properties are only required if the attribute name contains dashes. Finally, add the definition to the global provider: Globalprovider.bootstrap({ components: [...components], // as usual expanders: [SearchExpander] }) That's it, a lot less to write without the effort to create components. It's just text-replacement before the renderer grabs the content, so no performance impact at runtime. The expander logic does not perform any kebab-pascal conversion as some other tools do (that means, the name myProp does not appear as my-prop automatically).","title":"n-expand"},{"location":"md/docs/lib/template/#quick-expanders","text":"Quick expanders are even easier, but more for local expanding. const d = { 'type': \"text\"; 'placeholder': \"Name\"; 'role': \"search\"; 'class': \"materialinput\"; } <app-button {...d} /> It's just pure ECMAScript magic, no code from @nyaf required.","title":"Quick Expanders"},{"location":"md/docs/store/dispose/","text":"Disposing # Some event handlers and especially the store environment need a proper removing of handlers. This happens in the dispose method you can override in the component. The @Dispose decorator is provided by the base library in @nyaf/lib . It will be triggered by the lifecycle event and is independent of the store infrastructure. Using Dispose with Store # This is how it looks like: constructor() { super(); this.tabSubscriber = this.store.subscribe('tab', (data: globalStoreType) => { document.querySelector<SlotTabsComponent>('#demoTabs')?.setTab(data.tab); }); this.tabSubscriberCheckRemoving = this.store.subscribe('tab', (data: globalStoreType) => { console.log('Tab Subscriber received change from store'); }); } store: Store<globalStoreType>; dispose() { if (this.tabSubscriber) { this.tabSubscriber.remove(); } if (this.tabSubscriberCheckRemoving) { this.tabSubscriberCheckRemoving.remove(); } } Even easier is the usage of the Dispose decorator like this: @Dispose(s => s.remove()) private readonly tabSubscriber; @Dispose(s => s.remove()) private readonly tabSubscriberCheckRemoving; You can now remove the dispose method entirely. The variable s in the example code is the current property the decorator is placed on ( tabSubscriber or tabSubscriberCheckRemoving ). The call convention depends on the object the property returns. There is no error handling internally, the code is executed \"as is\". General Usage # The @Dispose decorator is defined in the base library and not limited to store actions. The callback function has access to the current property and can execute anything on behalf of it.","title":"Disposing Subscriptions"},{"location":"md/docs/store/dispose/#disposing","text":"Some event handlers and especially the store environment need a proper removing of handlers. This happens in the dispose method you can override in the component. The @Dispose decorator is provided by the base library in @nyaf/lib . It will be triggered by the lifecycle event and is independent of the store infrastructure.","title":"Disposing"},{"location":"md/docs/store/dispose/#using-dispose-with-store","text":"This is how it looks like: constructor() { super(); this.tabSubscriber = this.store.subscribe('tab', (data: globalStoreType) => { document.querySelector<SlotTabsComponent>('#demoTabs')?.setTab(data.tab); }); this.tabSubscriberCheckRemoving = this.store.subscribe('tab', (data: globalStoreType) => { console.log('Tab Subscriber received change from store'); }); } store: Store<globalStoreType>; dispose() { if (this.tabSubscriber) { this.tabSubscriber.remove(); } if (this.tabSubscriberCheckRemoving) { this.tabSubscriberCheckRemoving.remove(); } } Even easier is the usage of the Dispose decorator like this: @Dispose(s => s.remove()) private readonly tabSubscriber; @Dispose(s => s.remove()) private readonly tabSubscriberCheckRemoving; You can now remove the dispose method entirely. The variable s in the example code is the current property the decorator is placed on ( tabSubscriber or tabSubscriberCheckRemoving ). The call convention depends on the object the property returns. There is no error handling internally, the code is executed \"as is\".","title":"Using Dispose with Store"},{"location":"md/docs/store/dispose/#general-usage","text":"The @Dispose decorator is defined in the base library and not limited to store actions. The callback function has access to the current property and can execute anything on behalf of it.","title":"General Usage"},{"location":"md/docs/store/effects/","text":"Effects Mapping # A component is basically just an user interface (UI), that is defined by HTML. This UI can be dynamic in both directions, receiving user actions and react to changes in an underlying data model. In business components this leads to a significant amount of code, that is primarily just a reference to the coding environment. For user actions it's a number of event hooks leading to handlers. For data changes it's the binding to a model and code to monitor changes. The Flux store reduces the amount of code by moving the actual business logic to the reducer functions. That a big progress compared to traditional programming styles, but the remaining definitions are now only skeletons to function calls. It would be great to have these function calls reduced to the bare minimum of code and, in the same step, collected in one single definition just like the reducers. This features exists in @nyaf and it's called Effects . The Effects Decorator # The decorator exists once on a component. The API looks like this: @Effects(Effect[]) It makes only sense in conjunction with the store itself. This is how it goes with a real component: @CustomElement('app-store-effects') @ProvideStore<allStoreTypes>(store) @Effects([ { selector: 'button[data-action=\"ADD\"]', trigger: 'click', parameter: (e) => (e.target as HTMLElement).dataset.payload || 1, action: INC } ]) export class StoreEffectsComponent extends BaseComponent<{ cnt: number }> implements IStore<allStoreTypes> { } Imagine this code in a component without effects: <button class='btn btn-md btn-success' type='button' n-on-click={e => this.clickMeAdd(e)}> Add 1 </button> clickMeAdd(e) { this.store.dispatch(INC, 1); } The whole purpose of the code is to add a click event and trigger the dispatcher. Effects move both parts outside of the component and you can remove the code entirely. The view becomes simpler and the component is smaller and less error-prone. Using the Effects Decorator # To keep the handler stuff outside the component and still connected to one we use a decorator. The following example gives you an impression how this could look like: @Effects([ { selector: '[data-action=\"ADD\"]', trigger: 'click', parameter: (e) => (e.target as HTMLElement).dataset.payload || 1, action: INC }, { selector: '[data-action=\"SUB\"]', trigger: 'click', parameter: (e) => (e.target as HTMLElement).dataset.payload || 1, action: DEC }, { selector: '[data-action=\"SET\"]', trigger: 'click', parameter: (e) => +(e.target as HTMLElement).dataset.payload, action: SET } ]) The decorator accepts an array of objects of type Effect . This type is an interface that has the following API: selector : A string that can be handled by querySelectorAll . trigger : A string that is one of the common ECMAScript events an element can fire or any custom event name. action : A string constant that the store's reducer accept in a dispatch call. parameter : An (optional) function that retrieves a value from the event handler parameter. The Selector # The selector is a string that can be handled by querySelectorAll . This is mandatory and the selector must return at least one element. The selector is executed after the life cycle event state Load . That means, that the render function is executed. The selector will not get any elements you add later dynamically. To avoid any conflicts it's strongly recommended to use data- attributes and avoid any CSS stuff to select elements, especially not the class attribute. The Trigger # The trigger is a string that is one of the common ECMAScript events an element can fire or any custom event name. To support IntelliSense a number of common events is part of the definition, but technically it's allowed to use any string here. Internally the event is attached to the outcome of the selector by using addEventHandler(trigger) . The Action Definition # The action is a string constant that the store's reducer accept in a dispatch call. It's recommended to use the action constants and not provide any string values here directly. The binder class that handles this internally will throw an exception in case the action is not known by the store. The Parameter # The Parameter is a function that retrieves a value from the event handler parameter. This is the only optional value. You can omit it in case the dispatched action does not need a payload. For all other reducer calls this function returns a value that's being used as the payload. The returned type is always any without further restrictions. The input parameter is the event's parameter object. In most cases it's of type Event , or KeyEvent , or MouseEvent . In case of a custom component it could be CustomEvent . To retrieve values the best way is to access the source element by using this code snippet: const element = (e.target as HTMLElement); To provide dynamic values the data- attributes are a robust way doing so. To access the values directly use the dataset property. In case your attribute is further divided in sections using the kebab-style (such as in data-action-value ) the dataset property converts this into camel case ( action-value transforms into actionValue ). But, you can use any other property of the event source to set values. You can also simply use static values, too. However, even if technically possible, it's not recommended to add any business logic or validation code in this functions. Move such code consequently to the reducer. Otherwise you logic code will be split-up and becomes very hard to maintain. The reason the @Effects decorator exists is just to get a more rigid structure in your app.","title":"Effects Mapping"},{"location":"md/docs/store/effects/#effects-mapping","text":"A component is basically just an user interface (UI), that is defined by HTML. This UI can be dynamic in both directions, receiving user actions and react to changes in an underlying data model. In business components this leads to a significant amount of code, that is primarily just a reference to the coding environment. For user actions it's a number of event hooks leading to handlers. For data changes it's the binding to a model and code to monitor changes. The Flux store reduces the amount of code by moving the actual business logic to the reducer functions. That a big progress compared to traditional programming styles, but the remaining definitions are now only skeletons to function calls. It would be great to have these function calls reduced to the bare minimum of code and, in the same step, collected in one single definition just like the reducers. This features exists in @nyaf and it's called Effects .","title":"Effects Mapping"},{"location":"md/docs/store/effects/#the-effects-decorator","text":"The decorator exists once on a component. The API looks like this: @Effects(Effect[]) It makes only sense in conjunction with the store itself. This is how it goes with a real component: @CustomElement('app-store-effects') @ProvideStore<allStoreTypes>(store) @Effects([ { selector: 'button[data-action=\"ADD\"]', trigger: 'click', parameter: (e) => (e.target as HTMLElement).dataset.payload || 1, action: INC } ]) export class StoreEffectsComponent extends BaseComponent<{ cnt: number }> implements IStore<allStoreTypes> { } Imagine this code in a component without effects: <button class='btn btn-md btn-success' type='button' n-on-click={e => this.clickMeAdd(e)}> Add 1 </button> clickMeAdd(e) { this.store.dispatch(INC, 1); } The whole purpose of the code is to add a click event and trigger the dispatcher. Effects move both parts outside of the component and you can remove the code entirely. The view becomes simpler and the component is smaller and less error-prone.","title":"The Effects Decorator"},{"location":"md/docs/store/effects/#using-the-effects-decorator","text":"To keep the handler stuff outside the component and still connected to one we use a decorator. The following example gives you an impression how this could look like: @Effects([ { selector: '[data-action=\"ADD\"]', trigger: 'click', parameter: (e) => (e.target as HTMLElement).dataset.payload || 1, action: INC }, { selector: '[data-action=\"SUB\"]', trigger: 'click', parameter: (e) => (e.target as HTMLElement).dataset.payload || 1, action: DEC }, { selector: '[data-action=\"SET\"]', trigger: 'click', parameter: (e) => +(e.target as HTMLElement).dataset.payload, action: SET } ]) The decorator accepts an array of objects of type Effect . This type is an interface that has the following API: selector : A string that can be handled by querySelectorAll . trigger : A string that is one of the common ECMAScript events an element can fire or any custom event name. action : A string constant that the store's reducer accept in a dispatch call. parameter : An (optional) function that retrieves a value from the event handler parameter.","title":"Using the Effects Decorator"},{"location":"md/docs/store/effects/#the-selector","text":"The selector is a string that can be handled by querySelectorAll . This is mandatory and the selector must return at least one element. The selector is executed after the life cycle event state Load . That means, that the render function is executed. The selector will not get any elements you add later dynamically. To avoid any conflicts it's strongly recommended to use data- attributes and avoid any CSS stuff to select elements, especially not the class attribute.","title":"The Selector"},{"location":"md/docs/store/effects/#the-trigger","text":"The trigger is a string that is one of the common ECMAScript events an element can fire or any custom event name. To support IntelliSense a number of common events is part of the definition, but technically it's allowed to use any string here. Internally the event is attached to the outcome of the selector by using addEventHandler(trigger) .","title":"The Trigger"},{"location":"md/docs/store/effects/#the-action-definition","text":"The action is a string constant that the store's reducer accept in a dispatch call. It's recommended to use the action constants and not provide any string values here directly. The binder class that handles this internally will throw an exception in case the action is not known by the store.","title":"The Action Definition"},{"location":"md/docs/store/effects/#the-parameter","text":"The Parameter is a function that retrieves a value from the event handler parameter. This is the only optional value. You can omit it in case the dispatched action does not need a payload. For all other reducer calls this function returns a value that's being used as the payload. The returned type is always any without further restrictions. The input parameter is the event's parameter object. In most cases it's of type Event , or KeyEvent , or MouseEvent . In case of a custom component it could be CustomEvent . To retrieve values the best way is to access the source element by using this code snippet: const element = (e.target as HTMLElement); To provide dynamic values the data- attributes are a robust way doing so. To access the values directly use the dataset property. In case your attribute is further divided in sections using the kebab-style (such as in data-action-value ) the dataset property converts this into camel case ( action-value transforms into actionValue ). But, you can use any other property of the event source to set values. You can also simply use static values, too. However, even if technically possible, it's not recommended to add any business logic or validation code in this functions. Move such code consequently to the reducer. Otherwise you logic code will be split-up and becomes very hard to maintain. The reason the @Effects decorator exists is just to get a more rigid structure in your app.","title":"The Parameter"},{"location":"md/docs/store/example/","text":"The Store Types # The store has these basic parts as described before: Actions Reducer Store and Store Types The actions are basically string constants. The reducers get a payload that can be simply anything, including null or undefined . The return value is the store type. The store has two basic function: Use dispatch to send action objects. These objects trigger the respective reducer functions. The subscribe method allows to attach an event handler that receives store updates. You dispatch an action along with a payload. So, the types are string or Symbol for the name and any for the payload. When you receive a store event from a subscriber, this subscription watches for changes of a part of the store type. The event handler receives the whole store, then. Examining an Example # Assume we deal with a CRUD (Create, Read, Update, Delete) component using a custom model like this: import { Display } from '@nyaf/forms'; import { TemplateHint } from '@nyaf/forms'; import { Sortable } from '@nyaf/forms'; import { Hidden } from '@nyaf/forms'; export class ArchivModel { @Hidden() id: number = 0; @Display('Closet') @Sortable() @TemplateHint('table-column', { width: 50 }) Closet: string = ''; @Display('Name') @Sortable() @TemplateHint('table-column', { width: 100 }) Name: string = ''; @Display('Surname') @Sortable() @TemplateHint('table-column', { width: 100 }) Surname: string = ''; @Display('Birthday') @TemplateHint('table-column', { width: 100 }) Birthday: string = ''; @Display('Number of Files') @TemplateHint('table-column', { width: 30 }) NoFiles: number = 1; @Display('Archived') @Sortable() @TemplateHint('table-column', { width: 50 }) ArchivedYear: number = 2010; } The decorators are from the @nyaf/forms library. Now, some actions are required: import { ArchivModel } from '../model/archiv.model'; export const ALL = Symbol('ALL'); export const EDIT = Symbol('EDIT'); export const ADD = Symbol('ADD'); export const SAVE = Symbol('SAVE'); export const REMOVE = Symbol('REMOVE'); /** * The defaults that we use as long as the code hasn't sent anything. */ export default { [ALL]: () => '', [EDIT]: () => new ArchivModel(), [ADD]: () => new ArchivModel(), [SAVE]: () => new ArchivModel(), [REMOVE]: () => 0, }; The functions of the actions are executed if the dispatch call provides nothing ( undefined - exactly). In that case the value from the function is pulled. Also, some reducers doing the hard work ( DatabaseService is an example service proxy not shown here; see the full example code on Github in the examples path): import { ALL, ADD, REMOVE, EDIT, SAVE } from '../actions/archive.actions'; import { archiveStoreType } from '../stores/archive.store'; import { DatabaseService } from 'app/services/database.service'; import { DataGridModel } from 'app/components/shared/grid/models/datagrid.model'; import { ArchivModel } from '../model/archiv.model'; import * as $sql from 'app/resources/sql.json'; /** * The reducer functions are the executing logic. They \"do\" what the action is asking for. */ export default { [ALL]: async (state: archiveStoreType, payload: string) => { const data: any = await DatabaseService.instance.instance.exec($sql.ArchivAnzeigen); const modelData = new DataGridModel<ArchivModel>(data, ArchivModel); state.gridResult = modelData; return state; }, [EDIT]: async (state: archiveStoreType, payload: number) => { const [current]: any = await DatabaseService.instance.instance.exec($sql.ArchivAnzeigenAktuelles, payload); state.current = current; return state; }, [ADD]: (state: archiveStoreType, payload: ArchivModel) => { state.current = null; return state; }, [SAVE]: async (state: archiveStoreType, payload: ArchivModel) => { const data: any = await DatabaseService.instance.instance.exec( payload.id ? $sql.ArchivUpdate : $sql.ArchivInsert, payload.Schrank, payload.Vorname, payload.Nachname, payload.Geburtsdatum, payload.AnzahlAkten, payload.ArchivJahr, payload.id ); const modelData = new DataGridModel<ArchivModel>(data, ArchivModel); state.gridResult = modelData; return state; }, [REMOVE]: async (state: archiveStoreType, payload: number) => { const data: any = await DatabaseService.instance.instance.exec($sql.ArchivEntfernenFinal, payload); const modelData = new DataGridModel<ArchivModel>(data, ArchivModel); state.gridResult = modelData; return state; }, }; DatabaseService.instance.instance is a service class with singleton pattern. It executes SQL. \\$sql provides the statements from a resource file. The store summarizes all this for easy processing: import { ArchivModel } from '../model/archiv.model'; import { DataGridModel } from 'app/components/shared/grid/models/datagrid.model'; export interface ArchiveStore { current: ArchivModel; gridResult: DataGridModel<ArchivModel>; } /** * A store contains a data structure that helds up to the entire app's state. * It can have any complexity, from a single value up to deep nested objects. */ export interface ActionStore { search: string; } /** * We export a single store type that contains all single stores as one default. */ export type archiveStoreType = ActionStore & ArchiveStore; import archiveReducer from '../reducer/archive.reducer'; import archiveActions, { SEARCH, ADD, REMOVE, ALL, ARCHIVED, EDIT } from '../actions/archive.actions'; import { Store } from '@nyaf/store'; const store = new Store<archiveStoreType>({ actions: archiveActions, reducer: { ...archiveReducer }, state: { search: '', current: null, gridResult: null }, }); export default store; Now, the component can dispatch actions with payloads and receive store changes. @CustomElement('tab-archive-search') @ProvideStore<archiveStoreType>(store) export class ArchiveSearchComponent extends StoreComponent<archiveStoreType, {}> { constructor() { super(); this.store.subscribe('gridResult', (data: archiveStoreType) => { // Do something with the data }); } private async showAll(e?: Event) { this.store.dispatch(ALL, null); } // render omitted for brevity } The reducer receives the ALL action. It pulls all the data and sets the gridResult object. The subscriber listens for this and can handle the data (re-render, for example). The essential part is here that the return value of the subscriber is always the Store Type (here archiveStoreType ). So you don't need to think about the current type and TypeScript resolves the types within properly. However, the subscriber is for just one property of the store and only changes of this property will trigger the handler. To get the data, access it like this: archiveStoreType.gridResult; The underlying object is Proxy , not your actual type.","title":"The Store Types"},{"location":"md/docs/store/example/#the-store-types","text":"The store has these basic parts as described before: Actions Reducer Store and Store Types The actions are basically string constants. The reducers get a payload that can be simply anything, including null or undefined . The return value is the store type. The store has two basic function: Use dispatch to send action objects. These objects trigger the respective reducer functions. The subscribe method allows to attach an event handler that receives store updates. You dispatch an action along with a payload. So, the types are string or Symbol for the name and any for the payload. When you receive a store event from a subscriber, this subscription watches for changes of a part of the store type. The event handler receives the whole store, then.","title":"The Store Types"},{"location":"md/docs/store/example/#examining-an-example","text":"Assume we deal with a CRUD (Create, Read, Update, Delete) component using a custom model like this: import { Display } from '@nyaf/forms'; import { TemplateHint } from '@nyaf/forms'; import { Sortable } from '@nyaf/forms'; import { Hidden } from '@nyaf/forms'; export class ArchivModel { @Hidden() id: number = 0; @Display('Closet') @Sortable() @TemplateHint('table-column', { width: 50 }) Closet: string = ''; @Display('Name') @Sortable() @TemplateHint('table-column', { width: 100 }) Name: string = ''; @Display('Surname') @Sortable() @TemplateHint('table-column', { width: 100 }) Surname: string = ''; @Display('Birthday') @TemplateHint('table-column', { width: 100 }) Birthday: string = ''; @Display('Number of Files') @TemplateHint('table-column', { width: 30 }) NoFiles: number = 1; @Display('Archived') @Sortable() @TemplateHint('table-column', { width: 50 }) ArchivedYear: number = 2010; } The decorators are from the @nyaf/forms library. Now, some actions are required: import { ArchivModel } from '../model/archiv.model'; export const ALL = Symbol('ALL'); export const EDIT = Symbol('EDIT'); export const ADD = Symbol('ADD'); export const SAVE = Symbol('SAVE'); export const REMOVE = Symbol('REMOVE'); /** * The defaults that we use as long as the code hasn't sent anything. */ export default { [ALL]: () => '', [EDIT]: () => new ArchivModel(), [ADD]: () => new ArchivModel(), [SAVE]: () => new ArchivModel(), [REMOVE]: () => 0, }; The functions of the actions are executed if the dispatch call provides nothing ( undefined - exactly). In that case the value from the function is pulled. Also, some reducers doing the hard work ( DatabaseService is an example service proxy not shown here; see the full example code on Github in the examples path): import { ALL, ADD, REMOVE, EDIT, SAVE } from '../actions/archive.actions'; import { archiveStoreType } from '../stores/archive.store'; import { DatabaseService } from 'app/services/database.service'; import { DataGridModel } from 'app/components/shared/grid/models/datagrid.model'; import { ArchivModel } from '../model/archiv.model'; import * as $sql from 'app/resources/sql.json'; /** * The reducer functions are the executing logic. They \"do\" what the action is asking for. */ export default { [ALL]: async (state: archiveStoreType, payload: string) => { const data: any = await DatabaseService.instance.instance.exec($sql.ArchivAnzeigen); const modelData = new DataGridModel<ArchivModel>(data, ArchivModel); state.gridResult = modelData; return state; }, [EDIT]: async (state: archiveStoreType, payload: number) => { const [current]: any = await DatabaseService.instance.instance.exec($sql.ArchivAnzeigenAktuelles, payload); state.current = current; return state; }, [ADD]: (state: archiveStoreType, payload: ArchivModel) => { state.current = null; return state; }, [SAVE]: async (state: archiveStoreType, payload: ArchivModel) => { const data: any = await DatabaseService.instance.instance.exec( payload.id ? $sql.ArchivUpdate : $sql.ArchivInsert, payload.Schrank, payload.Vorname, payload.Nachname, payload.Geburtsdatum, payload.AnzahlAkten, payload.ArchivJahr, payload.id ); const modelData = new DataGridModel<ArchivModel>(data, ArchivModel); state.gridResult = modelData; return state; }, [REMOVE]: async (state: archiveStoreType, payload: number) => { const data: any = await DatabaseService.instance.instance.exec($sql.ArchivEntfernenFinal, payload); const modelData = new DataGridModel<ArchivModel>(data, ArchivModel); state.gridResult = modelData; return state; }, }; DatabaseService.instance.instance is a service class with singleton pattern. It executes SQL. \\$sql provides the statements from a resource file. The store summarizes all this for easy processing: import { ArchivModel } from '../model/archiv.model'; import { DataGridModel } from 'app/components/shared/grid/models/datagrid.model'; export interface ArchiveStore { current: ArchivModel; gridResult: DataGridModel<ArchivModel>; } /** * A store contains a data structure that helds up to the entire app's state. * It can have any complexity, from a single value up to deep nested objects. */ export interface ActionStore { search: string; } /** * We export a single store type that contains all single stores as one default. */ export type archiveStoreType = ActionStore & ArchiveStore; import archiveReducer from '../reducer/archive.reducer'; import archiveActions, { SEARCH, ADD, REMOVE, ALL, ARCHIVED, EDIT } from '../actions/archive.actions'; import { Store } from '@nyaf/store'; const store = new Store<archiveStoreType>({ actions: archiveActions, reducer: { ...archiveReducer }, state: { search: '', current: null, gridResult: null }, }); export default store; Now, the component can dispatch actions with payloads and receive store changes. @CustomElement('tab-archive-search') @ProvideStore<archiveStoreType>(store) export class ArchiveSearchComponent extends StoreComponent<archiveStoreType, {}> { constructor() { super(); this.store.subscribe('gridResult', (data: archiveStoreType) => { // Do something with the data }); } private async showAll(e?: Event) { this.store.dispatch(ALL, null); } // render omitted for brevity } The reducer receives the ALL action. It pulls all the data and sets the gridResult object. The subscriber listens for this and can handle the data (re-render, for example). The essential part is here that the return value of the subscriber is always the Store Type (here archiveStoreType ). So you don't need to think about the current type and TypeScript resolves the types within properly. However, the subscriber is for just one property of the store and only changes of this property will trigger the handler. To get the data, access it like this: archiveStoreType.gridResult; The underlying object is Proxy , not your actual type.","title":"Examining an Example"},{"location":"md/docs/store/globloc/","text":"Global and Local Store # Technically there is just one store. But logically you will usually split the access into a global store (per app or module) and a local one - per component. Merge Strategy # Within a component the stores are being merged and appear as one unit afterwards.","title":"Global and Local Stores"},{"location":"md/docs/store/globloc/#global-and-local-store","text":"Technically there is just one store. But logically you will usually split the access into a global store (per app or module) and a local one - per component.","title":"Global and Local Store"},{"location":"md/docs/store/globloc/#merge-strategy","text":"Within a component the stores are being merged and appear as one unit afterwards.","title":"Merge Strategy"},{"location":"md/docs/store/overview/","text":"The Flux Store # This module is the store implementation, a simple flux variant without the burden of Redux. It strictly follows the flux pattern and brings, ones fully understood, a great amount of strict programming style to your application. It brings state to your single page app (SPA). Outside of a SPA it's not useful. How it works # It's very much like Redux, but makes use of decorators to write less code. It's a good strategy to create one global store in your app. Leave it empty if there are no global actions, but make it global if you have such actions. Then, define three parts for each implementation: Actions that the component offers (such as SEARCH, LOAD, SET, REMOVE, you name it) Reducers that are pure function calls that do what your business logic requires (change data, call services) A State Object that holds all the data. The reducer can change the state, but nobody else can In the component you have two tasks: Dispatch actions and add payload if required. Listen for changes in the store to know when an reducer finished it's task. An async load must not be split-up. The calls are async, hence the state change may appear later, but nonetheless it lands in the component eventually. Actions # Define the capabilities of your app, along with some default or initial value. In this example I use Symbol to define unique constants that are being used for any further request of an action. export const INC = Symbol('INC'); export const DEC = Symbol('DEC'); export const SET = Symbol('SET'); export default { // initial value of payload, // this can be omitted if you don't care [INC]: () => 1, [DEC]: () => -1, SET }; The following figure shows the relevant parts of the action definition: Why using actions? It's convenient to have typed constants in the editor and use easy to remember names without the chance to create mistakenly typos. Reducer # Define, what happens if an action is being dispatched: import { INC, DEC } from '../actions/counter.action'; import stateType from '../states/counter.state'; export default { [INC]: (state: stateType, payload: number) => { state.counter = state.counter + payload; return state; }, [DEC]: (state: stateType, payload: number) => { state.counter = state.counter - payload; return state; } }; The following figure shows the relevant parts of the reducer definition: The returned payload is the whole store object by reference. The type for the store is optional and helps elevating the power of TypeScript and getting a type safe store. Why using reducers at all? Pure function calls are the foundation of a side effect free business layer. You have exactly one location where the logic goes - the reducer. That's said, from now on you will know where to have logic, where to have UI, and where to store everything. Reducers can be sync or async, every function can be made as you like. Return Value Considerations # The return value is an object that contains the fragments of the store that need to be changed. Through subscriptions this is the way to inform other instances that something happened. But be careful with setting multiple values in one single step. The store logic will execute property by property and immediately publish the change event. A subscriber will receive the changes in the exact order of the properties in the reducers returns value. If the subscriber receives the first property's change event, the ne value is provided. However, the remaining values are not yet set, and hence the store is in an intermediate state. You must wait for all subscribers to get their final values. The best way to avoid hassle here is to avoid returning multiple values from a single reducer function. Store and Dispatcher # The store holds the state, provides a dispatch function and fires events in case a store value changes. First, the store can by defined by types, but this is an option and you may decide to go with a simple object just for the sake of simplicity. The example shows a store that consists of fragments. This allows one to use parts of the store just by using the type fragments. // This is a store fragment export interface DemoTitleStore { title: string; } // This is a store fragment export interface CounterStore { counter: number; } // This is the complete store, which can be used complete or in fragments type store = CounterStore & DemoTitleStore; // This is for convenient access export default store; Now see the usage within a component. First, you must configure the store with the elements written before. As shown it's easy to combine reducers and add the various actions. To have the state typed a generic is being used. import counterReducer from '../reducer/counter.reducer'; import setReducer from '../reducer/set.reducer'; import counterActions from '../actions/counter.action'; import storeStateType from '../states/counter.state'; const store = new Store<storeStateType>({ actions: counterActions, mutations: { ...counterReducer, ...setReducer }, state: { counter: 0 } }); Use the Store # Now make the store constant available in the component, if it's not yet defined there. This particular store can handle just one single component or spread multiple components and form eventually a single source of truth for the whole application. @CustomElement('app-store-counter') @ProvideStore<storeStateType>(store) export class StoreCounterComponent extends BaseComponent<{ cnt: number }> implements IStore<storeStateType> { constructor() { super(); this.setData('cnt', 0); // fire if a value changes in the store, // takes name of the store value this.store.subscribe('counter', str => { // write to a observed property to force re-render this.data.cnt = str.counter; }); } clickMeAdd(e) { console.log('Counter Element Click INC'); this.store.dispatch(INC, 1); } clickMeSub(e) { console.log('Counter Element Click DEC'); this.store.dispatch(DEC, 1); } clickMeSet(e) { console.log('Counter Element Click SET'); this.store.dispatch(SET, 100); } render() { return ( <> <div> <button type='button' n-on-click={this.clickMeAdd}> Add 1 </button> <button type='button' n-on-click={this.clickMeSub}> Sub 1 </button> <button type='button' n-on-click={this.clickMeSet}> Set 100 </button> </div> <pre style='border: 1px solid gray;'>{this.data.cnt}</pre> </> ); } } The decorator @ProvideStore<T>(storeInstance) in the example activates the store and creates an instance in the property this.store . To help TypeScript to understand the existence of this property you must implement the interface IStore<T> with the same type as used in the decorator. Now you have access and an already existing instance. The store gives you access to the two main features, dispatching actions and subscribing to changes. Pro Tip! Combine this example with the forms module ( @nyaf/forms ) and get binding on element level using the n-bind template feature.","title":"Overview"},{"location":"md/docs/store/overview/#the-flux-store","text":"This module is the store implementation, a simple flux variant without the burden of Redux. It strictly follows the flux pattern and brings, ones fully understood, a great amount of strict programming style to your application. It brings state to your single page app (SPA). Outside of a SPA it's not useful.","title":"The Flux Store"},{"location":"md/docs/store/overview/#how-it-works","text":"It's very much like Redux, but makes use of decorators to write less code. It's a good strategy to create one global store in your app. Leave it empty if there are no global actions, but make it global if you have such actions. Then, define three parts for each implementation: Actions that the component offers (such as SEARCH, LOAD, SET, REMOVE, you name it) Reducers that are pure function calls that do what your business logic requires (change data, call services) A State Object that holds all the data. The reducer can change the state, but nobody else can In the component you have two tasks: Dispatch actions and add payload if required. Listen for changes in the store to know when an reducer finished it's task. An async load must not be split-up. The calls are async, hence the state change may appear later, but nonetheless it lands in the component eventually.","title":"How it works"},{"location":"md/docs/store/overview/#actions","text":"Define the capabilities of your app, along with some default or initial value. In this example I use Symbol to define unique constants that are being used for any further request of an action. export const INC = Symbol('INC'); export const DEC = Symbol('DEC'); export const SET = Symbol('SET'); export default { // initial value of payload, // this can be omitted if you don't care [INC]: () => 1, [DEC]: () => -1, SET }; The following figure shows the relevant parts of the action definition: Why using actions? It's convenient to have typed constants in the editor and use easy to remember names without the chance to create mistakenly typos.","title":"Actions"},{"location":"md/docs/store/overview/#reducer","text":"Define, what happens if an action is being dispatched: import { INC, DEC } from '../actions/counter.action'; import stateType from '../states/counter.state'; export default { [INC]: (state: stateType, payload: number) => { state.counter = state.counter + payload; return state; }, [DEC]: (state: stateType, payload: number) => { state.counter = state.counter - payload; return state; } }; The following figure shows the relevant parts of the reducer definition: The returned payload is the whole store object by reference. The type for the store is optional and helps elevating the power of TypeScript and getting a type safe store. Why using reducers at all? Pure function calls are the foundation of a side effect free business layer. You have exactly one location where the logic goes - the reducer. That's said, from now on you will know where to have logic, where to have UI, and where to store everything. Reducers can be sync or async, every function can be made as you like.","title":"Reducer"},{"location":"md/docs/store/overview/#return-value-considerations","text":"The return value is an object that contains the fragments of the store that need to be changed. Through subscriptions this is the way to inform other instances that something happened. But be careful with setting multiple values in one single step. The store logic will execute property by property and immediately publish the change event. A subscriber will receive the changes in the exact order of the properties in the reducers returns value. If the subscriber receives the first property's change event, the ne value is provided. However, the remaining values are not yet set, and hence the store is in an intermediate state. You must wait for all subscribers to get their final values. The best way to avoid hassle here is to avoid returning multiple values from a single reducer function.","title":"Return Value Considerations"},{"location":"md/docs/store/overview/#store-and-dispatcher","text":"The store holds the state, provides a dispatch function and fires events in case a store value changes. First, the store can by defined by types, but this is an option and you may decide to go with a simple object just for the sake of simplicity. The example shows a store that consists of fragments. This allows one to use parts of the store just by using the type fragments. // This is a store fragment export interface DemoTitleStore { title: string; } // This is a store fragment export interface CounterStore { counter: number; } // This is the complete store, which can be used complete or in fragments type store = CounterStore & DemoTitleStore; // This is for convenient access export default store; Now see the usage within a component. First, you must configure the store with the elements written before. As shown it's easy to combine reducers and add the various actions. To have the state typed a generic is being used. import counterReducer from '../reducer/counter.reducer'; import setReducer from '../reducer/set.reducer'; import counterActions from '../actions/counter.action'; import storeStateType from '../states/counter.state'; const store = new Store<storeStateType>({ actions: counterActions, mutations: { ...counterReducer, ...setReducer }, state: { counter: 0 } });","title":"Store and Dispatcher"},{"location":"md/docs/store/overview/#use-the-store","text":"Now make the store constant available in the component, if it's not yet defined there. This particular store can handle just one single component or spread multiple components and form eventually a single source of truth for the whole application. @CustomElement('app-store-counter') @ProvideStore<storeStateType>(store) export class StoreCounterComponent extends BaseComponent<{ cnt: number }> implements IStore<storeStateType> { constructor() { super(); this.setData('cnt', 0); // fire if a value changes in the store, // takes name of the store value this.store.subscribe('counter', str => { // write to a observed property to force re-render this.data.cnt = str.counter; }); } clickMeAdd(e) { console.log('Counter Element Click INC'); this.store.dispatch(INC, 1); } clickMeSub(e) { console.log('Counter Element Click DEC'); this.store.dispatch(DEC, 1); } clickMeSet(e) { console.log('Counter Element Click SET'); this.store.dispatch(SET, 100); } render() { return ( <> <div> <button type='button' n-on-click={this.clickMeAdd}> Add 1 </button> <button type='button' n-on-click={this.clickMeSub}> Sub 1 </button> <button type='button' n-on-click={this.clickMeSet}> Set 100 </button> </div> <pre style='border: 1px solid gray;'>{this.data.cnt}</pre> </> ); } } The decorator @ProvideStore<T>(storeInstance) in the example activates the store and creates an instance in the property this.store . To help TypeScript to understand the existence of this property you must implement the interface IStore<T> with the same type as used in the decorator. Now you have access and an already existing instance. The store gives you access to the two main features, dispatching actions and subscribing to changes. Pro Tip! Combine this example with the forms module ( @nyaf/forms ) and get binding on element level using the n-bind template feature.","title":"Use the Store"},{"location":"md/docs/store/setup/","text":"Installation # Install the store package like this: npm i @nyaf/store -S The type definitions required for TypeScript are part of the packages and no additional type libraries are required. Dependencies # The one and only dependency is the core library, @nyaf/lib .","title":"Setup"},{"location":"md/docs/store/setup/#installation","text":"Install the store package like this: npm i @nyaf/store -S The type definitions required for TypeScript are part of the packages and no additional type libraries are required.","title":"Installation"},{"location":"md/docs/store/setup/#dependencies","text":"The one and only dependency is the core library, @nyaf/lib .","title":"Dependencies"},{"location":"md/docs/store/updates/","text":"Automatic Updates # The @Updates decorator complements the @Effects decorator. The schema is similar. However, both decorators work independently of each other and you can use any or both. Using @Updates and @Effects is comparable with React Hooks, but in combination more powerful. The Updates Decorator # The decorator exists once on a component. The API looks like this: @Updates(Update[]) It makes only sense in conjunction with the store itself (a missing store will throw an exception). This is how it goes with a real component: @CustomElement('app-store-effects') @ProvideStore<allStoreTypes>(store) @Updates<allStoreTypes>([ { store: 'counter', selector: '[data-store-counter]', target: 'textContent' } ]) export class StoreUpdateComponent extends BaseComponent<{ cnt: number }> implements IStore<allStoreTypes> { } The piece of HTML that this @Update decorator setting addresses is shown below: <div class='badge badge-info' data-store-counter>n/a</div> There is no additional code required to update the HTML. Once a change in the store ocurred the value is pulled from the store and written into the selected property. In the example the store's value 'counter' is monitored by a subscription. The elements are being selected once in the lifecycle state Load . Further changes of the component's DOM are not being processed. The access works with or without shadow DOM. The element's selector in the example is '[data-store-counter]'. You can use any selector querySelectorAll would accept. If there are multiple elements indeed, the assignment will happen multiple times. The target property is 'textContent'. You can use any property that the selected element or component supports. Be aware that the access is property access on code level. That means, a virtual attribute of a component will not work, because it's not change in markup. If you have a component as the target, and wish to write a value to an observed attribute, you must introduce getter and setter methods to support the @Update decorator. In the example the store definition (using @ProvideStore ) and the update configuration (using @Updates ) use the very same store type. That's not necessary. If the store type is a combined type (as in the example code you can find on Github), consider using one of its partial types for the update to shrink the selection to the part you really need. This avoids errors and improves the readability of your code. Using the Updates Decorator # The following code shows the typical store subscription, usually assigned in the constructor: this.sub = this.store.subscribe('counter', str => { this.querySelector('[data-store-counter]').textContent = str.counter; }); The value is written in a freshly selected element. The very same result can be achieved with the following code: @Updates<allStoreTypes>([ { store: 'counter', selector: '[data-store-counter]', target: 'textContent' }]) While this not seem to be a big advantage (in fact, 2 lines more), the real reason is to avoid any code in the component directly, making it pure view. On the long term this creates clean code and helps to make a ore systematic structure. The decorator accepts an array of objects of type Update . This type is an interface that has the following API: selector : A string that can be handled by querySelectorAll . store : A string that is one of the properties of the store type. This is managed by the generic. target : A string that's the name of a property the selected element or component supports. This is not being checked by TypeScript. The Selector # The selector is a string that can be handled by querySelectorAll . This is mandatory and the selector must return at least one element. The selector is executed after the life cycle event state Load . That means, that the render function is executed. The selector will not get any elements you add later dynamically. To avoid any conflicts it's strongly recommended to use data- attributes and avoid any CSS stuff to select elements, especially not the class attribute. The Store # The store has usually a type definition to define the fundamental structure. Usually it's just an interface. The generic provides this type definition and you can choose any of these properties. Internally it's a keyof T definition. The Target # Because you can't write a value straight into an element or into a component you must define a specific property. The type is either any of the properties supported by HTMLElement or just a string. This is weak from standpoint of Intellisense (in fact, there is actually no check at all), but flexible enough to support all common scenarios. It's a trade-off between convenience and security. A more rigid approach would require a generic on the level of the Update interface. But with an anonymous type definition you can't provide a generic. That means you need to add an additional type information. In the end it's a lot more boilerplate code for a little safety. That's the reason while the definition can be made so simple.","title":"Automatic Updates"},{"location":"md/docs/store/updates/#automatic-updates","text":"The @Updates decorator complements the @Effects decorator. The schema is similar. However, both decorators work independently of each other and you can use any or both. Using @Updates and @Effects is comparable with React Hooks, but in combination more powerful.","title":"Automatic Updates"},{"location":"md/docs/store/updates/#the-updates-decorator","text":"The decorator exists once on a component. The API looks like this: @Updates(Update[]) It makes only sense in conjunction with the store itself (a missing store will throw an exception). This is how it goes with a real component: @CustomElement('app-store-effects') @ProvideStore<allStoreTypes>(store) @Updates<allStoreTypes>([ { store: 'counter', selector: '[data-store-counter]', target: 'textContent' } ]) export class StoreUpdateComponent extends BaseComponent<{ cnt: number }> implements IStore<allStoreTypes> { } The piece of HTML that this @Update decorator setting addresses is shown below: <div class='badge badge-info' data-store-counter>n/a</div> There is no additional code required to update the HTML. Once a change in the store ocurred the value is pulled from the store and written into the selected property. In the example the store's value 'counter' is monitored by a subscription. The elements are being selected once in the lifecycle state Load . Further changes of the component's DOM are not being processed. The access works with or without shadow DOM. The element's selector in the example is '[data-store-counter]'. You can use any selector querySelectorAll would accept. If there are multiple elements indeed, the assignment will happen multiple times. The target property is 'textContent'. You can use any property that the selected element or component supports. Be aware that the access is property access on code level. That means, a virtual attribute of a component will not work, because it's not change in markup. If you have a component as the target, and wish to write a value to an observed attribute, you must introduce getter and setter methods to support the @Update decorator. In the example the store definition (using @ProvideStore ) and the update configuration (using @Updates ) use the very same store type. That's not necessary. If the store type is a combined type (as in the example code you can find on Github), consider using one of its partial types for the update to shrink the selection to the part you really need. This avoids errors and improves the readability of your code.","title":"The Updates Decorator"},{"location":"md/docs/store/updates/#using-the-updates-decorator","text":"The following code shows the typical store subscription, usually assigned in the constructor: this.sub = this.store.subscribe('counter', str => { this.querySelector('[data-store-counter]').textContent = str.counter; }); The value is written in a freshly selected element. The very same result can be achieved with the following code: @Updates<allStoreTypes>([ { store: 'counter', selector: '[data-store-counter]', target: 'textContent' }]) While this not seem to be a big advantage (in fact, 2 lines more), the real reason is to avoid any code in the component directly, making it pure view. On the long term this creates clean code and helps to make a ore systematic structure. The decorator accepts an array of objects of type Update . This type is an interface that has the following API: selector : A string that can be handled by querySelectorAll . store : A string that is one of the properties of the store type. This is managed by the generic. target : A string that's the name of a property the selected element or component supports. This is not being checked by TypeScript.","title":"Using the Updates Decorator"},{"location":"md/docs/store/updates/#the-selector","text":"The selector is a string that can be handled by querySelectorAll . This is mandatory and the selector must return at least one element. The selector is executed after the life cycle event state Load . That means, that the render function is executed. The selector will not get any elements you add later dynamically. To avoid any conflicts it's strongly recommended to use data- attributes and avoid any CSS stuff to select elements, especially not the class attribute.","title":"The Selector"},{"location":"md/docs/store/updates/#the-store","text":"The store has usually a type definition to define the fundamental structure. Usually it's just an interface. The generic provides this type definition and you can choose any of these properties. Internally it's a keyof T definition.","title":"The Store"},{"location":"md/docs/store/updates/#the-target","text":"Because you can't write a value straight into an element or into a component you must define a specific property. The type is either any of the properties supported by HTMLElement or just a string. This is weak from standpoint of Intellisense (in fact, there is actually no check at all), but flexible enough to support all common scenarios. It's a trade-off between convenience and security. A more rigid approach would require a generic on the level of the Update interface. But with an anonymous type definition you can't provide a generic. That means you need to add an additional type information. In the end it's a lot more boilerplate code for a little safety. That's the reason while the definition can be made so simple.","title":"The Target"}]}